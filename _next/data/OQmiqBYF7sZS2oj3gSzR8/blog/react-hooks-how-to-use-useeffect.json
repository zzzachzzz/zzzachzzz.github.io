{"pageProps":{"post":{"title":"React Hooks: How to Use useEffect","date":"2021-03-04T18:04:42.446Z","content":"\nOf all the hooks built into React, `useEffect` is arguably the most difficult to understand. When I was learning React Hooks, I had just begun to get comfortable with class-based components and the lifecycle methods, such as `componentDidMount`. Part of the difficulty I had when learning `useEffect` was due to the fundamental differences between `useEffect` and the legacy React lifecycle methods. The best tutorials I've read on `useEffect` advise you to \"unlearn what you have learned\" in regard to lifecycle methods.\n\n[Dan Abramov has an excellent blog post on useEffect](https://overreacted.io/a-complete-guide-to-useeffect). It's very thorough, and thus a long read. This post will summarize many of the points Dan covers, and I'll cover some of the issues and solutions I've discovered while using `useEffect`.\n\nFirst, here is the function signature for `useEffect` as a TypeScript definition:\n\n```ts\ntype useEffect = (effect: EffectCallback, deps?: Array<any>) => void;\ntype EffectCallback = () => (void | (() => void));\n```\n\n`EffectCallback` is our function to execute as the effect, which can optionally return a [cleanup function](https://reactjs.org/docs/hooks-reference.html#cleaning-up-an-effect) that will be executed when the component unmounts, or when the effect is redefined. The optional second argument to `useEffect`, `deps`, is a \"dependency array\". If `deps` is omitted, then the effect will be executed (and redefined) after every render. When `deps` is included, the effect is only redefined and executed if any of the values provided to the array change from one execution to the next. Consequently, providing no values to the dependency array, `[]`, will result in the effect only being executed after the initial render. In determining if a dependency has changed, as far as I know, a strict equality comparison is performed (`===`). Note that arrays, objects, and functions are only equal by reference. In some situations this can be problematic. This blog post provides several solutions:  \n[Object & array dependencies in the React useEffect Hook](https://www.benmvp.com/blog/object-array-dependencies-react-useEffect-hook)\n\nWhy is it even necessary to have a dependency array? How could we be accessing stale values inside an effect?\n\nConsider the following snippet of vanilla JS:\n```js\nlet arr = [];\nlet y = 0;\n\nfunction pushFunc() {\n  y++;\n  let x = y;\n  arr.push(() => x);\n}\n\npushFunc();\npushFunc();\n\nconsole.log(arr[0]()); // 1\nconsole.log(arr[1]()); // 2\n```\nWe push two functions to an array, `() => x`, and each time this function is created, it captures `x` from its [closure](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures) within `pushFunc`. `x` from the first execution of `pushFunc` is not the same `x` in the second execution of `pushFunc`. When dealing with React, the same rules apply, whether those values come from props or state, as they're also just variables. This is because a React component is just a function, and plays by the same rules concerning function execution context.  \n1 render = 1 function call.\n\nIf we were to provide a function to `useEffect` with no dependency array; `useEffect(() => {...})`, the effect function we provide would be redefined after every render, receiving fresh values from the current execution context. The effect would also re-execute after every render. The dependency array serves two purposes:\n1. Tell React when to execute our effect\n2. Tell React when to redefine our effect\n\n## Example 1: Basic Usage with `fetch`\nThe most common use case for `useEffect` is fetching data from an API, and then updating the state of a component to render that data in the UI.\n\n```jsx\nfunction Todo({ id }) {\n  const [todo, setTodo] = useState();\n\n  useEffect(() => {\n    fetch(`/api/todos/${id}`)\n      .then(res => res.json())\n      .then(json => setTodo(json));\n  }, []);\n\n  if (!todo) return null;\n  return <div>{todo.title}</div>;\n}\n```\n\nWhile we should avoid making too many comparisons to the class lifecycle methods, the above usage of `useEffect` with an empty dependency array `[]` is the rough equivalent of `componentDidMount`. The above does work in its current form, but we're lying to React about the dependency array. Running the above snippet through `eslint` configured with the rule `react-hooks/exhaustive-deps` gives us this warning:\n```\nReact Hook useEffect has a missing dependency: 'id'.\nEither include it or remove the dependency array\n```\nWe can fix this to become:\n\n```jsx\nuseEffect(() => {\n  ...\n}, [id]);\n```\n\nBy providing `id` to the dependency array we are saying:  \n\"Whenever `id` changes, redefine and rerun this effect.\"\n\n`id` may or may not change depending on how the parent component of our `Todo` component gets a todo id, and provides that prop. If our `Todo` component were to receive a different `id` prop, then we probably would want to fetch the todo corresponding to that new id, calling our effect provided to `useEffect` again.\n\nTechnically `setTodo` should be included in the dependency array too. However, since it is a function we get from our `useState` hook, its identity is guaranteed to be stable, so it will never change. Furthermore, **in newer versions of the `react-hooks/exhaustive-deps` rule, the linter won't tell us to include a `useState` `set_` function, nor the `dispatch` function returned by `useReducer`.** It's safe to omit these specific functions from the dependency array. Just not other functions, as we will see in the next section.\n\n## Example 2: Functions as Dependencies\nNext, let's take a look at functions as effect dependencies:\n\n```jsx\nfunction Todo({ id }) {\n  const [todo, setTodo] = useState();\n\n  function fetchTodo() {\n    return fetch(`/api/todos/${id}`);\n  }\n\n  useEffect(() => {\n    fetchTodo()\n      .then(res => res.json())\n      .then(json => setTodo(json));\n  }, []);\n\n  if (!todo) return null;\n  return <div>{todo.title}</div>;\n}\n```\n\nIn this example, our effect calls a function, `fetchTodo`. This code contains a bug. :bug: Because we omit `fetchTodo` from our effect's dependency array, our effect captures only the original definition of `fetchTodo`, and in turn, that instance of `fetchTodo` only captures the initial value of the `id` prop. If `id` changes, our effect will reference the original stale value. Like in the first example, `id` is a dependency we need to inform our effect about. The difference is, we've now made that dependency indirect by accessing `id` inside `fetchTodo` rather than directly inside our effect callback.\n\nThere's a problem with simply adding `fetchTodo` to the dependency array to solve this. Because `fetchTodo` will be redefined on each render / execution of our `Todo` component, `fetchTodo` will have a new \"value\" / \"function identity\" each time, resulting in the effect being triggered on every render. There are two solutions to this problem:\n\n### Solution #1\nInclude `fetchTodo` in the dependency array, and define `fetchTodo` with [useCallback](https://reactjs.org/docs/hooks-reference.html#usecallback). Like `useEffect`, `useCallback` also accepts a dependency array. Because `fetchTodo` references `id` in its function body, we need to include `id` in its dependency array:\n\n```jsx\nconst fetchTodo = useCallback(() => {\n  return fetch(`/api/todos/${id}`);\n}, [id]); // Whenever `id` changes, `fetchTodo` will be redefined\n\nuseEffect(() => {\n  fetchTodo()\n    .then(res => res.json())\n    .then(json => setTodo(json));\n}, [fetchTodo]); // Add `fetchTodo` to the effect's dependency array\n```\n\n### Solution #2\nThe other solution is to extract `fetchTodo` from the component entirely. Being outside the closure of the `Todo` component, it won't have access to the `id` prop, but we can supply that as an argument to the function. Extracting `fetchTodo` will allow its function identity to be stable across renders of `Todo`:\n```jsx\nfunction Todo({ id }) {\n  const [todo, setTodo] = useState();\n\n  useEffect(() => {\n    fetchTodo(id) // Pass `id` as an argument\n      .then(res => res.json())\n      .then(json => setTodo(json));\n  }, [id]); // `fetchTodo` now has a stable function identity\n\n  if (!todo) return null;\n  return <div>{todo.title}</div>;\n}\n\nfunction fetchTodo(id) { // Make `id` an argument\n  return fetch(`/api/todos/${id}`);\n}\n```\n\n## Example 3: Access Updated `props` Without Rerunning an Effect\nLet's look at another example. This one is a fairly unique case, as we need to access updated values in our effect, but re-executing the effect actually breaks the functionality we're going for:\n\n```jsx\nfunction Counter({ incrementBy }) {\n  const [num, setNum] = useState(0);\n\n  useEffect(() => {\n    const handle = setInterval(() => {\n      setNum(num + incrementBy);\n    }, 3000);\n\n    return () => clearInterval(handle);\n  }, [num, incrementBy]);\n\n  return <div>{num}</div>;\n}\n```\n\n`setNum` won't change, but `num` and `incrementBy` are both problematic. With `num` in the dependency array, and our effect updating `num` via `setNum`, this will cause our effect to be triggered every time `setNum(num + incrementBy)` is run. For setting state relying on previous state values, we can use the callback form of `setState`, and remove `num` as a dependency.\n\nIf `num` is omitted from the dependency array, the linter will actually suggest this solution to us:\n\n```\nReact Hook useEffect has a missing dependency: 'num'.\nEither include it or remove the dependency array.\nYou can also do a functional update 'setNum(n => ...)'\nif you only need 'num' in the 'setNum' call\n```\n\nTo use the functional update form of `setState`, we can change this to:\n\n```jsx\nfunction Counter({ incrementBy }) {\n  const [num, setNum] = useState(0);\n\n  useEffect(() => {\n    const handle = setInterval(() => {\n      setNum(prevNum => prevNum + incrementBy); // `num` is no longer used here\n    }, 3000);\n\n    return () => clearInterval(handle);\n  }, [incrementBy]); // `num` removed from dependency array\n\n  return <div>{num}</div>;\n}\n```\n\nNow we're left to deal with `incrementBy`. If this prop is updated, say from `10` to `20`, we do want that updated value to be referenced in our effect, rather than referencing a stale value. However, when our effect is redefined, we lose the timing of our interval, and a new interval is created. We have it setup to call `setNum(prevNum => prevNum + incrementBy)` every 3 seconds.\n\nWhat happens if just 1.5 seconds have passed for the interval, and the value of `incrementBy` changes?\n1. Our effect cleanup function we provided to React will be executed, `() => clearInterval(handle)`, clearing our current 3 second interval.\n2. Our effect will be redefined, creating a new 3 second interval, along with a new cleanup function.\n3. From there, 3 more seconds must pass before `setNum(...)` is called, for a total of 4.5 seconds since the last interval call (wrong behavior).\n\nThis example with `setInterval` provides us with a unique challenge. We want the updated values present in our effect, but we don't want the timing of our interval to be messed up, as a result of redefining our effect. `useReducer` can help us achieve this, by accessing updated props in our reducer function, rather than in `useEffect`:\n```jsx\nfunction Counter({ incrementBy }) {\n  const [num, incrementNum] = useReducer(\n    prevNum => prevNum + incrementBy, // Our \"setter\" (reducer function)\n    0 // Initial state\n  );\n\n  useEffect(() => {\n    const handle = setInterval(() => {\n      incrementNum();\n    }, 3000);\n\n    return () => clearInterval(handle);\n  }, []);\n\n  return <div>{num}</div>;\n}\n```\nWe use `useReducer` in a similar fashion to `useState`, but with the ability to specify what our \"setter\" function does, and for it to access updated props. `useReducer` is flexible in how you use it for your state. It can be used for simple, single value state, or more complex state objects. By convention, you'd normally see `useReducer` used like this: `const [state, dispatch] = useReducer(...)`. We instead choose to name these `num` & `incrementNum`. `incrementNum` is our `dispatch` function that `useReducer` returns to us, and it is guaranteed to have a stable function identity, preventing it from triggering `useEffect` to rerun. Since `incrementNum` is the `dispatch` function returned to us by `useReducer`, it can be omitted from the dependency array and the exhaustive deps linter won't complain.\n\n\n## Conclusion\nHopefully this post helped in understanding `useEffect`. As you can tell, the design of this hook by the React team is something that's opinionated and strict in how it is intended to be used, though that's not a bad thing. Being honest about an effect's dependencies is important in avoiding subtle bugs. We looked at some tricks that can be used to limit the number of dependencies in our effects. These recommended workarounds to reduce dependencies are something I wish was documented a little better in the official React docs. One of the more helpful parts of the docs is the [Hooks FAQ #Performance Optimizations](https://reactjs.org/docs/hooks-faq.html#performance-optimizations) section, which to me seems like more of a general usage guide. Knowing these recommended strategies for working with `useEffect` is crucial, as I've found that it's very easy to \"break the rules\" of `useEffect` when building real world applications.\n","slug":"react-hooks-how-to-use-useeffect"}},"__N_SSG":true}
{"pageProps":{"post":{"title":"Understanding Promises in JavaScript","date":"2019-08-29T20:35:44.000Z","content":"\nPromises are really confusing. There's a lot of keywords associated with promises and async JS:\n\n-   Promise\n-   resolve\n-   reject\n-   then\n-   catch\n-   async\n-   await\n\nFrom MDN:\n\n```javascript\nnew Promise(executor);\n```\n\n`executor`\n\n> A function that is passed with the arguments resolve and reject. The executor function is executed immediately by the Promise implementation, passing resolve and reject functions...\n\nSo if we break this down further, the expected arguments look like this:\n\n```javascript\nnew Promise(function executor(resolve, reject));\n```\n\nWe define the `executor` function, which receives `resolve` and `reject` callback functions as arguments.\n\n```javascript\nnew Promise(function executor(resolve, reject) {\n  if (true) {  // Success\n    resolve('Resolved the promise');\n  } else {  // Error\n    reject('Rejected the promise');\n  }\n});\n```\n\nThe `executor` function doesn't have to be named, I'm just making my example explicit.\n\nOnce the promise has been resolved or rejected, that will trigger either a chained `then` or `catch` to be called.\n\n```javascript\nnew Promise(function(resolve, reject) {\n  if (true) {  // Success\n    resolve('Resolved');\n  } else {  // Error\n    reject('Rejected');\n  }\n})\n.then(function(result) {\n  console.log(result);  // 'Resolved'\n})\n.catch(function(error) {\n  console.log(error);  // 'Rejected'\n});\n```\n\nAn alternative syntax (that I think is more confusing), is to pass a second argument to `then`, which will handle `reject` in place of `catch`. I would not recommend this but it's good to know.\n\n```javascript\nnew Promise(function executor(resolve, reject) {\n  if (true) {  // Success\n    resolve('Resolved');\n  } else {  // Error\n    reject('Rejected');\n  }\n})\n.then(function(result) {\n  console.log(result);  // 'Resolved'\n}, function(error) {\n  console.log(error);  // 'Rejected'\n});\n```\n\nNow that we understand the general behavior of Promises, let's break down this example `sleep` function.\n\n```javascript\nfunction sleep(ms) {\n  return new Promise(function(resolve) {\n    setTimeout(function() {\n      resolve('Resolved Value');\n    }, ms);\n  })\n}\n\nasync function main() {\n  console.log('Before sleep');\n  const resolvedValue = await sleep(5000);  // 5 seconds\n  console.log('After sleep');\n  console.log(resolvedValue);  // 'Resolved Value'\n}\n\nmain();\n```\n\nNormally if we were to call `sleep` without `await`, there would be no 5 second pause between the two log statements. That's because our `sleep` function returns a promise, so we must wait for it to be resolved if we want our `main` function to be executed synchronously.\n\nIn order to use the `await` keyword, the surrounding function, `main`, must be given the `async` keyword.\n\n`setTimeout` is an asynchronous function, one of few in JS's built in library. However, `setTimeout`_ is not a Promise-based asynchronous function, it is callback-based_. In order to `await` for `setTimeout` to complete, we must wrap it in a promise, and `resolve` that promise inside the callback function we provide to `setTimeout`.\n\nHere's a shorthand version of the above using arrow functions.\n\n```javascript\nconst sleep = ms => new Promise(resolve => setTimeout(() => resolve('Resolved Value'), ms));\n\nasync function main() {\n  console.log('Before sleep');\n  const resolvedValue = await sleep(5000);  // 5 seconds\n  console.log('After sleep');\n  console.log(resolvedValue);  // 'Resolved Value'\n}\n\nmain();\n```\n\nPromises are confusing. If you don't understand them fully, don't worry about it. Check out other resources, and most importantly, play around with the code yourself.\n","slug":"understanding-promises-in-javascript"}},"__N_SSG":true}
{"pageProps":{"post":{"title":"Hitting a Target File Size With FFmpeg (Perfect for Discord Clips)","date":"2025-12-10T12:43:16.627Z","content":"\nIf you've ever tried to send a gaming clip over Discord as a free user, you've run into the 10MB upload limit. My process before creating this script was to use a collection of other ffmpeg commands to trial-and-error trimming the clip, and lowering the quality until it finally went below the 10MB threshold.\n\nI wanted a way to say: **\"Here's my clip. Make it 10MB. Do what you must.\"**\n\nSo I wrote a Bash function that uses FFmpeg's 2‑pass encoding method to reliably target a specific file size. It also has quality‑of‑life options for trimming timestamps. As you'll see below, you can write other bash functions which call the main function to make this process happen by typing just a few characters into your terminal.\n\nMy setup:\n\n- Gaming on Windows, running the script in WSL (Git Bash will work too)\n- Shadowplay 1 minute instant replay saved videos\n- Discord 10MB file upload limit (non-Nitro paid users)\n\n## Requirements\n- A Bash shell to run the script: Linux, WSL, or Git Bash\n- FFmpeg (should include `ffmpeg` & `ffprobe`)\n\n**NOTE** I have FFmpeg installed in my Linux distro mounted in WSL (more on that [here](/blog/accessing-a-dual-boot-linux-install-in-wsl-with-chroot)), but using WSL with FFmpeg installed in Windows, with the exe accessible in your `$PATH` should work too.\n\n## The Scripts\n\nAlso available as a [GitHub Gist](https://zzzachzzz.github.io/blog/hitting-a-target-file-size-with-ffmpeg-perfect-for-discord-clips)\n\n### `vidunderfilesize.sh`\n\n```bash\n#!/usr/bin/env bash\n\neval set -- \"$(\n  getopt \\\n    --options s:e:i:o:k:a: \\\n    --longoptions start:,end:,input:,output:,output-filesize-kb:,audio-bitrate-kbps: \\\n    -- \"$@\"\n)\"\n\nwhile true; do\n  case \"$1\" in\n    -s|--start) start_arg=\"$2\"; shift 2 ;;\n    -e|--end) end_arg=\"$2\"; shift 2 ;;\n    -i|--input) input=\"$2\"; shift 2 ;;\n    -o|--output) output=\"$2\"; shift 2 ;;\n    -k|--output-filesize-kb) output_filesize_kb=\"$2\"; shift 2 ;;\n    -a|--audio-bitrate-kbps) audio_bitrate_kbps=\"$2\"; shift 2 ;;\n    --) shift; break ;;\n  esac\ndone\n\nIFS=\":\" read -ra start_array <<< \"$start_arg\"\nIFS=\":\" read -ra end_array <<< \"$end_arg\"\n\n# Prepend default zeros, filling arrays to 3 slots\nwhile (( ${#start_array[@]} < 3 )); do\n  start_array=(0 ${start_array[@]})\ndone\nwhile (( ${#end_array[@]} < 3 )); do\n  end_array=(0 ${end_array[@]})\ndone\n\n# Pad left 2 digits for each slot\nfor i in \"${!start_array[@]}\"; do\n  start_array[$i]=$(printf \"%02d\" ${start_array[$i]})\ndone\nfor i in \"${!end_array[@]}\"; do\n  end_array[$i]=$(printf \"%02d\" ${end_array[$i]})\ndone\n\nstart_hours_part=${start_array[0]}\nstart_minutes_part=${start_array[1]}\nstart_seconds_part=${start_array[2]}\nstart_seconds=$(( $start_seconds_part + $start_minutes_part * 60 + $start_hours_part * 60 * 60 ))\nstart_time=\"$start_hours_part:$start_minutes_part:$start_seconds_part\"\n\n# If no end timestamp supplied (or user provided zeroes), get duration of video\nif [[ \"${end_array[@]}\" == \"00 00 00\" ]]; then\n  raw_duration_decimal=\"$(\n    ffprobe -v error -select_streams v:0 -show_entries stream=duration \\\n    -of default=noprint_wrappers=1:nokey=1 \"$input\"\n  )\"\n  end_seconds=\"$(awk -v d=\"$raw_duration_decimal\" 'BEGIN {print int(d)}')\"\n  # `end_time` intentionally not set\nelse\n  end_hours_part=${end_array[0]}\n  end_minutes_part=${end_array[1]}\n  end_seconds_part=${end_array[2]}\n  end_seconds=$(( $end_seconds_part + $end_minutes_part * 60 + $end_hours_part * 60 * 60 ))\n  end_time=\"$end_hours_part:$end_minutes_part:$end_seconds_part\"\nfi\n\nduration_seconds=$(( $end_seconds - $start_seconds ))\n\ndefault_audio_bitrate_kbps=\"128\"\naudio_bitrate_kbps=\"${audio_bitrate_kbps:-$default_audio_bitrate_kbps}\"\naudio_total_kb=$(( $audio_bitrate_kbps * $duration_seconds ))\n\n_10MB_in_kb=\"80000\" # 10 megabyte == 80,000 kilobits\noutput_filesize_kb=${output_filesize_kb:-$_10MB_in_kb}\n\nvideo_bitrate_kbps=$(( ( $output_filesize_kb - $audio_total_kb ) / $duration_seconds ))\n\n# tmp file written to in 1st pass and read in 2nd pass\nffmpeg_stats_file=\"$(mktemp --tmpdir --dry-run ffmpeg_stats_XXXXXX)\"\n\nmaybe_to=\"$([[ -n $end_time ]] && echo \"-to $end_time\")\"\nffmpeg_common_output_file_options=\"\\\n-ss $start_time $maybe_to \\\n-c:v libx264 -b:v ${video_bitrate_kbps}k \\\n-maxrate 5M -bufsize 10M \\\n-passlogfile $ffmpeg_stats_file \\\n$FFMPEG_OUTPUT_FILE_OPTIONS\\\n\"\n\n# 1st pass ffmpeg analyzes video and outputs stats file to `$ffmpeg_stats_file*`,\n# to accurately target `$output_filesize_kb` based on specified bitrates.\nffmpeg -y -i \"$input\" \\\n  $ffmpeg_common_output_file_options \\\n  -pass 1 \\\n  -an -f mp4 \\\n  /dev/null\n\n# 2nd pass produces actual video output, reading from stats files produced in 1st pass\nffmpeg -i \"$input\" \\\n  $ffmpeg_common_output_file_options \\\n  -pass 2 \\\n  -c:a aac -b:a \"${audio_bitrate_kbps}k\" \\\n  \"$output\"\n\n# Clean up tmp files, mbtree file is ~20MB\nrm \"$ffmpeg_stats_file\"*.log{,.mbtree}\n\n```\n\nAdditionally, here is my own helper function I use for calling the main script. I suggest you create one too.\n\n```bash\nfunction meleeclip() {\n  local start=\"$1\"\n  local end=\"$2\"\n  local input=\"$3\"\n  local output=\"$4\"\n  # Defaults for empty start & end options handled in `vidunderfilesize.sh`\n  [[ \"$start\" == \"-\" ]] && start=\"\"\n  [[ \"$end\" == \"-\" ]] && end=\"\"\n\n  if [[ -z \"$input\" || \"$input\" == \"-\" ]]; then\n    local input_dir=\"/mnt/d/storage/Videos/shadowplay/slippi dolphin.exe\"\n    local newest_file=\"$(ls -tp \"$input_dir\" | grep -v \"/$\" | head -n 1)\"\n    input=\"${input_dir}/${newest_file}\"\n  fi\n\n  if [[ -z \"$output\" || \"$output\" == \"-\" ]]; then\n    local output_dir=\"/mnt/d/storage/Videos/shadowplay/slippi dolphin.exe/cropped-clips\"\n    local output_filename=\"_NEW_CLIP_NAME_ME_$(basename \"$input\")\"\n    output=\"${output_dir}/${output_filename}\"\n  fi\n\n  FFMPEG_OUTPUT_FILE_OPTIONS=\"-vf crop=in_h*4/3:in_h\" \\\n    ~/bin/vidunderfilesize.sh \\\n    --start=\"$start\" \\\n    --end=\"$end\" \\\n    --input=\"$input\" \\\n    --output=\"$output\"\n}\n```\n\n## Usage\n\n`FFMPEG_OUTPUT_FILE_OPTIONS` is an option you probably don't need. Here I am cropping to 4:3 aspect ratio to closely match [Slippi Dolphin Melee's](https://melee.tv) internal resolution of 73:60.\n\nThe `--start` and `--end` options allow you to specify the timestamps you want to trim the clip to. The parsing is flexible and allows for these example inputs, converting to `hh:mm:ss`.\n\n- `5` -> `00:00:05`\n- `1:50` -> `00:01:50`\n- `01:1:01` -> `01:01:01`\n\nWith the `meleeclip` helper function I have, this is how I would typically call it:\n\n```bash\n# Let's say we want to clip from 00:00:36 to the end of my 1 minute clip\nmeleeclip 36\n\n# Or from 00:00:36 to 00:00:50\nmeleeclip 36 50\n```\n\nThat's it, since I have the `meleeclip` function default to use the newest file in my shadowplay directory as input, and a fixed output directory with a generated filename that I just go and rename separately after.\n\n## Explanation\n\nBitrate is predictable for producing a given filesize. File size is basically:\n\n```\nfile_size_bits ≈ bitrate_bits_per_sec × duration_sec\n```\n\nSo if you want a 10MB clip:\n\n```\n10 MB (Megabytes) = 80 Mb (megabits)\n10 MB = 80000 Kb (kilobits)\ntarget_bitrate_kbps = 80000 Kb / duration_seconds\n```\n\nIn the script, we calculate the maximum video bitrate we can use:\n```bash\nvideo_bitrate_kbps=$(( ( $output_filesize_kb - $audio_total_kb ) / $duration_seconds ))\n```\n\nOnce you know the exact bitrate needed, FFmpeg can aim for it, and using **2‑pass encoding**, it can hit that target very accurately.\n\n","slug":"hitting-a-target-file-size-with-ffmpeg-perfect-for-discord-clips"}},"__N_SSG":true}
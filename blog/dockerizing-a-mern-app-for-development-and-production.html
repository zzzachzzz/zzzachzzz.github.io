<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Dockerizing a MERN App for Development and Production</title><meta name="next-head-count" content="3"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/_next/static/css/069ff64b07ed1af4.css" as="style"/><link rel="stylesheet" href="/_next/static/css/069ff64b07ed1af4.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-b77228c2c91ffd3d.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-9d34f203832e9748.js" defer=""></script><script src="/_next/static/chunks/pages/_app-87c9684c861525e0.js" defer=""></script><script src="/_next/static/chunks/792-95b7cdfb484c5ddc.js" defer=""></script><script src="/_next/static/chunks/619-3b017027e2c3e013.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-04f0b5c0d6bf318f.js" defer=""></script><script src="/_next/static/7PXe33b0ovhWkt1a7aaJz/_buildManifest.js" defer=""></script><script src="/_next/static/7PXe33b0ovhWkt1a7aaJz/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">html{font-size:16px;min-height:100vh;}/*!sc*/
html,body{height:100%;margin:0;padding:0;}/*!sc*/
@media only screen and (max-device-width:480px){html{font-size:14px;}}/*!sc*/
body{background-color:#3e4d4f;color:white;font-family: -apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}/*!sc*/
*{box-sizing:border-box;}/*!sc*/
h1,h2,h3,h4,h5,h6{font-weight:400;}/*!sc*/
code,code[class*="language-"]{font-family: 'Inconsolata',Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace;}/*!sc*/
data-styled.g1[id="sc-global-laTLPJ1"]{content:"sc-global-laTLPJ1,"}/*!sc*/
.iCZgMf{background-color:#272822;padding:0.2em 0.4em;font-size:0.8em;border-radius:0.3em;color:#ae81ff;-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g2[id="A__A_-sc-14fqd0c-0"]{content:"iCZgMf,"}/*!sc*/
.imupSn{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:flex-start;-webkit-box-align:flex-start;-ms-flex-align:flex-start;align-items:flex-start;font-size:1.2em;-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g3[id="Navigation__Nav-sc-10fffhi-0"]{content:"imupSn,"}/*!sc*/
.bvlkze{margin:5px;}/*!sc*/
data-styled.g4[id="Navigation___StyledLink-sc-10fffhi-1"]{content:"bvlkze,"}/*!sc*/
.fCyYsH{margin:5px;}/*!sc*/
data-styled.g5[id="Navigation___StyledLink2-sc-10fffhi-2"]{content:"fCyYsH,"}/*!sc*/
.cLfdjf{margin:5px;}/*!sc*/
data-styled.g6[id="Navigation___StyledLink3-sc-10fffhi-3"]{content:"cLfdjf,"}/*!sc*/
.djnaNa{margin:5px;color:white;font-weight:500;line-height:1;}/*!sc*/
data-styled.g7[id="Navigation___StyledSpan-sc-10fffhi-4"]{content:"djnaNa,"}/*!sc*/
.fRlBcp{background-color:#272822;padding:0.2em 0.4em;font-size:0.8em;border-radius:0.3em;}/*!sc*/
data-styled.g17[id="Code-sc-1amjnp4-0"]{content:"fRlBcp,"}/*!sc*/
.cTrNrc{margin-left:auto !important;margin-right:auto !important;}/*!sc*/
data-styled.g18[id="TreeToJSX__Pre-sc-1taxolb-0"]{content:"cTrNrc,"}/*!sc*/
.bkGieB{color:#aaa;font-style:italic;border-left:2px solid #ddd;margin-left:0;margin-right:0;padding-left:10px;}/*!sc*/
data-styled.g19[id="TreeToJSX__BlockQuote-sc-1taxolb-1"]{content:"bkGieB,"}/*!sc*/
.gacNJW > p{margin:0;}/*!sc*/
data-styled.g20[id="TreeToJSX__Li-sc-1taxolb-2"]{content:"gacNJW,"}/*!sc*/
.fyBgXB{font-size:1.2em;line-height:1.4em;-webkit-letter-spacing:0.01em;-moz-letter-spacing:0.01em;-ms-letter-spacing:0.01em;letter-spacing:0.01em;overflow-wrap:break-word;padding:1.1em;margin:0 auto;}/*!sc*/
.fyBgXB > *:not(pre){max-width:850px;margin-left:auto;margin-right:auto;}/*!sc*/
.fyBgXB > pre{width:90vw;max-width:1100px;}/*!sc*/
data-styled.g23[id="slug__BlogContentContainer-sc-8mhdoa-0"]{content:"fyBgXB,"}/*!sc*/
.deOAlt{text-align:center;margin:2em;margin-bottom:0.2em;}/*!sc*/
data-styled.g24[id="slug___StyledH-sc-8mhdoa-1"]{content:"deOAlt,"}/*!sc*/
.bupMXj{font-size:0.9em;text-align:center;}/*!sc*/
data-styled.g25[id="slug___StyledP-sc-8mhdoa-2"]{content:"bupMXj,"}/*!sc*/
</style><style data-href="https://fonts.googleapis.com/css2?family=Inconsolata&display=swap">@font-face{font-family:'Inconsolata';font-style:normal;font-weight:400;font-stretch:normal;font-display:swap;src:url(https://fonts.gstatic.com/s/inconsolata/v31/QldgNThLqRwH-OJ1UHjlKENVzkWGVkL3GZQmAwLYxYWI2qfdm7Lpp4U8aRk.woff) format('woff')}@font-face{font-family:'Inconsolata';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/inconsolata/v31/QldgNThLqRwH-OJ1UHjlKENVzkWGVkL3GZQmAwLYxYWI2qfdm7Lpp4U8WRL2kXWdycuJDETf.woff) format('woff');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Inconsolata';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/inconsolata/v31/QldgNThLqRwH-OJ1UHjlKENVzkWGVkL3GZQmAwLYxYWI2qfdm7Lpp4U8WRP2kXWdycuJDETf.woff) format('woff');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Inconsolata';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/inconsolata/v31/QldgNThLqRwH-OJ1UHjlKENVzkWGVkL3GZQmAwLYxYWI2qfdm7Lpp4U8WR32kXWdycuJDA.woff) format('woff');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><div><nav class="Navigation__Nav-sc-10fffhi-0 imupSn"><a href="/" target="_self" rel="noopener noreferrer" class="A__A_-sc-14fqd0c-0 iCZgMf Navigation___StyledLink-sc-10fffhi-1 bvlkze">/</a><span class="Navigation___StyledSpan-sc-10fffhi-4 djnaNa">&gt;</span><a href="/blog" target="_self" rel="noopener noreferrer" class="A__A_-sc-14fqd0c-0 iCZgMf Navigation___StyledLink2-sc-10fffhi-2 fCyYsH">blog</a><span class="Navigation___StyledSpan-sc-10fffhi-4 djnaNa">&gt;</span><a href="/blog/dockerizing-a-mern-app-for-development-and-production" target="_self" rel="noopener noreferrer" class="A__A_-sc-14fqd0c-0 iCZgMf Navigation___StyledLink3-sc-10fffhi-3 cLfdjf">dockerizing-a-mern-app-for-development-and-production</a></nav><main><header><h1 class="slug___StyledH-sc-8mhdoa-1 deOAlt">Dockerizing a MERN App for Development and Production</h1><p class="slug___StyledP-sc-8mhdoa-2 bupMXj"><time dateTime="2020-10-25T16:30:43.234Z">October 25, 2020</time></p></header><article><div class="slug__BlogContentContainer-sc-8mhdoa-0 fyBgXB"><p>Creating a Dockerfile for a single service usually isn&#x27;t too bad. The example Dockerfile provided by the official guide for Node.js, <a href="https://nodejs.org/en/docs/guides/nodejs-docker-webapp/" target="_blank" rel="noopener noreferrer" class="A__A_-sc-14fqd0c-0 iCZgMf">Dockerizing a Node.js web app</a>, can be copied almost exactly.</p><p>However, things start to get a little more complicated when we want to:</p><ul><li class="TreeToJSX__Li-sc-1taxolb-2 gacNJW"><p>Create configurations for both development and production environments</p></li><li class="TreeToJSX__Li-sc-1taxolb-2 gacNJW"><p>Enable hot reloading in development (avoid needing Docker to re-build for every change)</p></li><li class="TreeToJSX__Li-sc-1taxolb-2 gacNJW"><p>Orchestrate connecting multiple services together (relevant for any web app with a frontend, backend, database, etc.)</p></li><li class="TreeToJSX__Li-sc-1taxolb-2 gacNJW"><p>Persist data in a database between runs (with Docker volumes)</p></li></ul><p>The app I&#x27;ll be using as an example can be found here: <a href="https://github.com/zzzachzzz/zzzachzzz.github.io/tree/2ab6f0b10606162a57b946461c4dae74e2a295d5" target="_blank" rel="noopener noreferrer" class="A__A_-sc-14fqd0c-0 iCZgMf">https://github.com/zzzachzzz/zzzachzzz.github.io/tree/2ab6f0b10606162a57b946461c4dae74e2a295d5</a><br/>I will also include the various Docker files in this post.</p><blockquote class="TreeToJSX__BlockQuote-sc-1taxolb-1 bkGieB"><p><b>Edit (Feb. 15, 2021)</b><br/>Yep, that&#x27;s the source code for this site, at a prior commit. The site has since been migrated to Next.js with static site generation. To learn more about that, see the post:<br/><a href="/blog/going-truly-serverless-with-nextjs-static-site-generation" target="_self" rel="noopener noreferrer" class="A__A_-sc-14fqd0c-0 iCZgMf">Going Truly Serverless with Next.js Static Site Generation</a></p></blockquote><p>To Dockerize a React app, we&#x27;ll definitely want a config for development, and production. In development, webpack-dev-server (<code class="Code-sc-1amjnp4-0 fRlBcp">npm run [start|react-scripts-start]</code> in CRA) will be used with hot-reloading. In production, there are multiple ways to go about it, but I&#x27;ll be using Nginx to serve the bundle, and proxying <code class="Code-sc-1amjnp4-0 fRlBcp">/api</code> requests to the Express app.</p><p><code class="Code-sc-1amjnp4-0 fRlBcp">frontend/Dockerfile.dev</code>:</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc  language-dockerfile"><code class="  language-dockerfile"><span class="token instruction"><span class="token keyword">FROM</span> node:14</span>
<span class="token instruction"><span class="token keyword">WORKDIR</span> /usr/src/frontend</span>
<span class="token instruction"><span class="token keyword">COPY</span> package*.json ./</span>
<span class="token instruction"><span class="token keyword">RUN</span> npm install</span>
<span class="token instruction"><span class="token keyword">EXPOSE</span> 3000</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"npm"</span>, <span class="token string">"run"</span>, <span class="token string">"start"</span>]</span></code></pre><p>One thing to note for proxying requests in development. If using CRA, you&#x27;ve likely set <code class="Code-sc-1amjnp4-0 fRlBcp">&quot;proxy&quot;: &quot;http://localhost:&lt;port&gt;&quot;</code> in <code class="Code-sc-1amjnp4-0 fRlBcp">package.json</code> before, to proxy requests from React to a server, like Express. When running the frontend and the backend in separate Docker containers, they don&#x27;t share the same localhost. Instead, we need to provide the network address created by Docker to connect the two together. You&#x27;ll see more of this in later steps involving the Docker Compose <code class="Code-sc-1amjnp4-0 fRlBcp">.yml</code> files, but as far as Webpack is concerned, we&#x27;ll need to provide it a config file for the proxy:</p><p><code class="Code-sc-1amjnp4-0 fRlBcp">frontend/src/setupProxy.js</code>:</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc  language-js"><code class="  language-js"><span class="token keyword">const</span> <span class="token punctuation">{</span> createProxyMiddleware <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http-proxy-middleware'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token constant">EXPRESS_HOST</span> <span class="token operator">=</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">EXPRESS_HOST</span> <span class="token operator">||</span> <span class="token string">'localhost'</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">app</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>
    <span class="token string">'/api'</span><span class="token punctuation">,</span>
    <span class="token function">createProxyMiddleware</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">target</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">http://</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">EXPRESS_HOST</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:5000</span><span class="token template-punctuation string">`</span></span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>Since I don&#x27;t know of a way to embed an environment variable in the <code class="Code-sc-1amjnp4-0 fRlBcp">package.json</code> file, this more advanced <code class="Code-sc-1amjnp4-0 fRlBcp">setupProxy.js</code> file is necessary. Notice the environment variable <code class="Code-sc-1amjnp4-0 fRlBcp">EXPRESS_HOST</code>. We will provide this variable to our Docker container, through our Docker Compose config. More on the above proxy config here: <a href="https://create-react-app.dev/docs/proxying-api-requests-in-development/#configuring-the-proxy-manually" target="_blank" rel="noopener noreferrer" class="A__A_-sc-14fqd0c-0 iCZgMf">https://create-react-app.dev/docs/proxying-api-requests-in-development/#configuring-the-proxy-manually</a></p><p><code class="Code-sc-1amjnp4-0 fRlBcp">frontend/Dockerfile.prod</code>:</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc  language-dockerfile"><code class="  language-dockerfile"><span class="token instruction"><span class="token keyword">FROM</span> node:14 <span class="token keyword">as</span> builder</span>
<span class="token instruction"><span class="token keyword">WORKDIR</span> /usr/src/frontend</span>
<span class="token instruction"><span class="token keyword">COPY</span> package*.json ./</span>
<span class="token instruction"><span class="token keyword">RUN</span> npm install</span>
<span class="token instruction"><span class="token keyword">COPY</span> . .</span>
<span class="token instruction"><span class="token keyword">RUN</span> npm run build</span>

<span class="token instruction"><span class="token keyword">FROM</span> nginx</span>
<span class="token instruction"><span class="token keyword">COPY</span> <span class="token options"><span class="token property">--from</span><span class="token punctuation">=</span><span class="token string">builder</span></span> /usr/src/frontend/build /usr/share/nginx/html</span>
<span class="token instruction"><span class="token keyword">COPY</span> nginx.conf /etc/nginx/conf.d/</span>
<span class="token instruction"><span class="token keyword">EXPOSE</span> 8080</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"nginx"</span>, <span class="token string">"-g"</span>, <span class="token string">"daemon off;"</span>]</span></code></pre><p>This is considered a multi-stage Docker build, due to the multiple <code class="Code-sc-1amjnp4-0 fRlBcp">FROM</code> statements. We build our Webpack bundle, beginning from the <code class="Code-sc-1amjnp4-0 fRlBcp">node:14</code> base image, and then switch to the <code class="Code-sc-1amjnp4-0 fRlBcp">nginx</code> base image to serve that Webpack bundle. Notice the line <code class="Code-sc-1amjnp4-0 fRlBcp">COPY nginx.conf /etc/nginx/conf.d/</code>, which refers to a <code class="Code-sc-1amjnp4-0 fRlBcp">nginx.conf</code> file I keep in Git.</p><p><code class="Code-sc-1amjnp4-0 fRlBcp">frontend/nginx.conf</code>:</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc  language-none"><code class="  language-none">server {
    listen 8080;

    location /api {
        proxy_pass http://backend:5000;
    }

    location / {
        root /usr/share/nginx/html;
        try_files $uri /index.html;
    }
}</code></pre><p><b>Note that my <code class="Code-sc-1amjnp4-0 fRlBcp">nginx.conf</code> is a bit abnormal</b>, since my server hosting the site has another Nginx instance running outside of Docker, which I have setup with <code class="Code-sc-1amjnp4-0 fRlBcp">location / { proxy_pass http://localhost:8080; }</code>. I have it setup this way so I can host multiple sites, and have Nginx handle routing traffic based on the <code class="Code-sc-1amjnp4-0 fRlBcp">server_name</code>. You&#x27;ll probably want your <code class="Code-sc-1amjnp4-0 fRlBcp">nginx.conf</code> setup to include sections for Certbot, to manage SSL certificates, and listen on port 80 &amp; 443. Consult another tutorial on Certbot &amp; Nginx for that.</p><p>The portion of this <code class="Code-sc-1amjnp4-0 fRlBcp">nginx.conf</code> file that is applicable to you is the <code class="Code-sc-1amjnp4-0 fRlBcp">proxy_pass</code> setup for <code class="Code-sc-1amjnp4-0 fRlBcp">/api</code> requests, which sends it to the network host <code class="Code-sc-1amjnp4-0 fRlBcp">backend</code> on port <code class="Code-sc-1amjnp4-0 fRlBcp">5000</code>. This is Docker managing networking again. In this case, <code class="Code-sc-1amjnp4-0 fRlBcp">backend</code>, is the name of our docker-compose service for Express, so Docker provides us the address for that specific container under the hostname <code class="Code-sc-1amjnp4-0 fRlBcp">backend</code>.</p><p>Before we get to those Docker Compose files that link everything together, there&#x27;s one more Dockerfile:</p><p><code class="Code-sc-1amjnp4-0 fRlBcp">backend/Dockerfile</code>:</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc  language-dockerfile"><code class="  language-dockerfile"><span class="token instruction"><span class="token keyword">FROM</span> node:14</span>
<span class="token instruction"><span class="token keyword">WORKDIR</span> /usr/src/backend</span>
<span class="token instruction"><span class="token keyword">COPY</span> package*.json ./</span>
<span class="token instruction"><span class="token keyword">RUN</span> npm install</span>
<span class="token instruction"><span class="token keyword">COPY</span> . .</span>
<span class="token instruction"><span class="token keyword">EXPOSE</span> 5000</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"node"</span>, <span class="token string">"app.js"</span>]</span></code></pre><p>For the backend, I don&#x27;t currently have a separate dev &amp; prod Dockerfile, however I would recommend it, with the use of <code class="Code-sc-1amjnp4-0 fRlBcp">nodemon</code> in place of <code class="Code-sc-1amjnp4-0 fRlBcp">node</code> in the <code class="Code-sc-1amjnp4-0 fRlBcp">CMD</code> statement in <code class="Code-sc-1amjnp4-0 fRlBcp">Dockerfile.dev</code>, to enable hot reloading in development.</p><p>Now onto the <code class="Code-sc-1amjnp4-0 fRlBcp">docker-compose.yml</code> files. I have 3 of these under the filenames <code class="Code-sc-1amjnp4-0 fRlBcp">docker-compose.yml</code>, <code class="Code-sc-1amjnp4-0 fRlBcp">docker-compose.override.yml</code>, and <code class="Code-sc-1amjnp4-0 fRlBcp">docker-compose.prod.yml</code>. You can choose different filenames, but there is a rational for these specific filenames. Both <code class="Code-sc-1amjnp4-0 fRlBcp">docker-compose.yml</code> and <code class="Code-sc-1amjnp4-0 fRlBcp">docker-compose.override.yml</code> are <a href="https://docs.docker.com/compose/extends/" target="_blank" rel="noopener noreferrer" class="A__A_-sc-14fqd0c-0 iCZgMf">filenames that Docker specifically looks for</a>. In both dev &amp; prod, we use 2 of these 3 docker-compose files.</p><ul><li class="TreeToJSX__Li-sc-1taxolb-2 gacNJW"><p><code class="Code-sc-1amjnp4-0 fRlBcp">docker-compose.yml</code> - The base config for dev &amp; prod</p></li><li class="TreeToJSX__Li-sc-1taxolb-2 gacNJW"><p><code class="Code-sc-1amjnp4-0 fRlBcp">docker-compose.override.yml</code> - The dev config overrides</p></li><li class="TreeToJSX__Li-sc-1taxolb-2 gacNJW"><p><code class="Code-sc-1amjnp4-0 fRlBcp">docker-compose.prod.yml</code> - The prod config overrides</p></li></ul><p>As shown in the Docker Compose docs linked above, multiple compose files can be specified with <code class="Code-sc-1amjnp4-0 fRlBcp">-f</code> like so (also see <code class="Code-sc-1amjnp4-0 fRlBcp">docker-compose --help</code>):<br/><code class="Code-sc-1amjnp4-0 fRlBcp">docker-compose -f docker-compose.yml -f docker-compose.prod.yml [COMMAND] [ARGS...]</code></p><p>Compose files specified are read from left to right, which means <code class="Code-sc-1amjnp4-0 fRlBcp">docker-compose.prod.yml</code> will be read last, giving it priority over our base <code class="Code-sc-1amjnp4-0 fRlBcp">docker-compose.yml</code>.</p><p>If no files are specified with <code class="Code-sc-1amjnp4-0 fRlBcp">-f</code>, Docker will do this:
<code class="Code-sc-1amjnp4-0 fRlBcp">docker-compose -f docker-compose.yml -f docker-compose.override.yml [COMMAND] [ARGS...]</code></p><p>Why does this matter? In development, when you want to use the dev config, <b>you don&#x27;t have to specify compose files for every <code class="Code-sc-1amjnp4-0 fRlBcp">docker-compose</code> command you want to execute</b>. Running your entire application&#x27;s stack in development becomes one short command: <code class="Code-sc-1amjnp4-0 fRlBcp">docker-compose up</code>. That&#x27;s it. Finally, here are those compose files:</p><p><code class="Code-sc-1amjnp4-0 fRlBcp">docker-compose.yml</code>:</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc  language-yml"><code class="  language-yml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.8"</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">frontend</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span>
      <span class="token key atrule">context</span><span class="token punctuation">:</span> ./frontend
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">EXPRESS_HOST</span><span class="token punctuation">:</span> backend

  <span class="token key atrule">backend</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span>
      <span class="token key atrule">context</span><span class="token punctuation">:</span> ./backend
      <span class="token key atrule">dockerfile</span><span class="token punctuation">:</span> Dockerfile
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"5000:5000"</span>
    <span class="token key atrule">env_file</span><span class="token punctuation">:</span> ./backend/.env
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">HOST</span><span class="token punctuation">:</span> 0.0.0.0
      <span class="token key atrule">MONGO_HOST</span><span class="token punctuation">:</span> mongo

  <span class="token key atrule">mongo</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> mongo<span class="token punctuation">:</span>latest
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"127.0.0.1:27017:27017"</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> mongo<span class="token punctuation">-</span>data<span class="token punctuation">:</span>/data/db

<span class="token key atrule">volumes</span><span class="token punctuation">:</span>
  mongo<span class="token punctuation">-</span>data<span class="token punctuation">:</span></code></pre><p><code class="Code-sc-1amjnp4-0 fRlBcp">docker-compose.override.yml</code>:</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc  language-yml"><code class="  language-yml"><span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">frontend</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span>
      <span class="token key atrule">dockerfile</span><span class="token punctuation">:</span> ./Dockerfile.dev
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"3000:3000"</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">NODE_ENV</span><span class="token punctuation">:</span> development
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ./frontend<span class="token punctuation">:</span>/usr/src/frontend
      <span class="token punctuation">-</span> /usr/src/frontend/node_modules
    <span class="token comment"># Due to stupid react-scripts bug still present in v3.4.3</span>
    <span class="token comment"># https://github.com/facebook/create-react-app/issues/8688</span>
    <span class="token key atrule">stdin_open</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>

  <span class="token key atrule">backend</span><span class="token punctuation">:</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">NODE_ENV</span><span class="token punctuation">:</span> development
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ./backend<span class="token punctuation">:</span>/usr/src/backend
      <span class="token punctuation">-</span> /usr/src/backend/node_modules</code></pre><p><code class="Code-sc-1amjnp4-0 fRlBcp">docker-compose.prod.yml</code>:</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc  language-yml"><code class="  language-yml"><span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">frontend</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span>
      <span class="token key atrule">dockerfile</span><span class="token punctuation">:</span> ./Dockerfile.prod
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"127.0.0.1:8080:8080"</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">NODE_ENV</span><span class="token punctuation">:</span> production

  <span class="token key atrule">backend</span><span class="token punctuation">:</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">NODE_ENV</span><span class="token punctuation">:</span> production</code></pre><p>There&#x27;s a lot we could go over in these compose files. I mentioned in the beginning that we want to enable hot-reloading in development, so that changes to code made on our host computer, are reflected in our Docker container, triggering a hot-reload from webpack-dev-server (or nodemon). The way we reflect file changes between host and container is through specifying <code class="Code-sc-1amjnp4-0 fRlBcp">volumes</code>:</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc  language-yml"><code class="  language-yml"><span class="token key atrule">volumes</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> ./frontend<span class="token punctuation">:</span>/usr/src/frontend
  <span class="token punctuation">-</span> /usr/src/frontend/node_modules</code></pre><p><code class="Code-sc-1amjnp4-0 fRlBcp">./frontend:/usr/src/frontend</code> maps our host&#x27;s <code class="Code-sc-1amjnp4-0 fRlBcp">./frontend</code> directory, to our container&#x27;s <code class="Code-sc-1amjnp4-0 fRlBcp">/usr/src/frontend</code> directory. Since our host may have its own <code class="Code-sc-1amjnp4-0 fRlBcp">node_modules</code> directory inside <code class="Code-sc-1amjnp4-0 fRlBcp">./frontend</code>, we don&#x27;t want this to be shared with the container. The container needs to maintain its own installed dependencies in isolation. To prevent our container&#x27;s <code class="Code-sc-1amjnp4-0 fRlBcp">node_modules</code> from being overwritten, we create an anonymous volume of our container&#x27;s <code class="Code-sc-1amjnp4-0 fRlBcp">/usr/src/frontend/node_modules</code> directory. The ordering of the two volumes listed is important, so that our container&#x27;s <code class="Code-sc-1amjnp4-0 fRlBcp">node_modules</code> stored in a volume have highest priority (applied last). I would recommend doing other research on Docker volumes to better understand the different types of volumes that Docker supports. Just note that we can tell Docker to persist its own <code class="Code-sc-1amjnp4-0 fRlBcp">node_modules</code> by creating an anonymous volume (we don&#x27;t assign a name to it), that Docker keeps track of with a generated hash as the volume name. This volume persists between container instances.</p><p>On the subject of volumes, another volume is very important to persist data in our Mongo database. Without a volume, our Mongo data would be lost every time out container stops and starts again, and we definitely don&#x27;t want to lose our DB data, at least in production. You&#x27;ll notice this volume is mentioned in two places:</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc  language-yml"><code class="  language-yml">  <span class="token key atrule">mongo</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> mongo<span class="token punctuation">:</span>latest
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"127.0.0.1:27017:27017"</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> mongo<span class="token punctuation">-</span>data<span class="token punctuation">:</span>/data/db

<span class="token key atrule">volumes</span><span class="token punctuation">:</span>
  mongo<span class="token punctuation">-</span>data<span class="token punctuation">:</span></code></pre><p>Why does <code class="Code-sc-1amjnp4-0 fRlBcp">mongo-data</code> appear twice? In this situation, we&#x27;re using a &quot;named volume&quot; (again, highly recommend reading more on these volume types). A named volume behaves quite similar to the anonymous volume I described earlier, except it&#x27;s named! We could technically make this volume anonymous, but it&#x27;s good to be able to identify the volume in case we need to manipulate it somehow, like making a backup of our database data. Named volumes must be defined in the top-level <code class="Code-sc-1amjnp4-0 fRlBcp">volumes</code> key, that&#x27;s why it appears in two places, unlike anonymous volumes.</p><p>See the Docker Compose docs on volumes: <a href="https://docs.docker.com/compose/compose-file/#volumes" target="_blank" rel="noopener noreferrer" class="A__A_-sc-14fqd0c-0 iCZgMf">https://docs.docker.com/compose/compose-file/#volumes</a></p><p>You may have noticed that ports are usually mapped like <code class="Code-sc-1amjnp4-0 fRlBcp">&quot;&lt;port&gt;:&lt;port&gt;&quot;</code>, without specifying a host. With this shorthand, the host is implied to be <code class="Code-sc-1amjnp4-0 fRlBcp">0.0.0.0</code>, listening on all interfaces. This makes it publicly accessible outside of the machine. If you don&#x27;t need to directly access Mongo (via the Mongo shell) remotely, and can instead do so over SSH, I highly recommend that for security. Especially with the default Mongo config for Docker, there will be no credentials required to access Mongo. This means that an attacker who only knows the IP address of your server can remotely access your database! Yes, I did learn that the hard way, thankfully with non-consequential data. 😅 So do yourself a favor and specify the mapping <code class="Code-sc-1amjnp4-0 fRlBcp">127.0.0.1:27017:27017</code> (<code class="Code-sc-1amjnp4-0 fRlBcp">localhost</code> for the host, implicit <code class="Code-sc-1amjnp4-0 fRlBcp">0.0.0.0</code> for the container).</p></div></article></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Dockerizing a MERN App for Development and Production","date":"2020-10-25T16:30:43.234Z","content":"\nCreating a Dockerfile for a single service usually isn't too bad. The example Dockerfile provided by the official guide for Node.js, [Dockerizing a Node.js web app](https://nodejs.org/en/docs/guides/nodejs-docker-webapp/), can be copied almost exactly.\n\nHowever, things start to get a little more complicated when we want to:\n* Create configurations for both development and production environments\n* Enable hot reloading in development (avoid needing Docker to re-build for every change)\n* Orchestrate connecting multiple services together (relevant for any web app with a frontend, backend, database, etc.)\n* Persist data in a database between runs (with Docker volumes)\n\nThe app I'll be using as an example can be found here: \u003chttps://github.com/zzzachzzz/zzzachzzz.github.io/tree/2ab6f0b10606162a57b946461c4dae74e2a295d5\u003e  \nI will also include the various Docker files in this post.\n\n\u003e**Edit (Feb. 15, 2021)**  \n\u003eYep, that's the source code for this site, at a prior commit. The site has since been migrated to Next.js with static site generation. To learn more about that, see the post:  \n[Going Truly Serverless with Next.js Static Site Generation](/blog/going-truly-serverless-with-nextjs-static-site-generation)\n\nTo Dockerize a React app, we'll definitely want a config for development, and production. In development, webpack-dev-server (`npm run [start|react-scripts-start]` in CRA) will be used with hot-reloading. In production, there are multiple ways to go about it, but I'll be using Nginx to serve the bundle, and proxying `/api` requests to the Express app.\n\n`frontend/Dockerfile.dev`:\n```dockerfile\nFROM node:14\nWORKDIR /usr/src/frontend\nCOPY package*.json ./\nRUN npm install\nEXPOSE 3000\nCMD [\"npm\", \"run\", \"start\"]\n```\n\nOne thing to note for proxying requests in development. If using CRA, you've likely set `\"proxy\": \"http://localhost:\u003cport\u003e\"` in `package.json` before, to proxy requests from React to a server, like Express. When running the frontend and the backend in separate Docker containers, they don't share the same localhost. Instead, we need to provide the network address created by Docker to connect the two together. You'll see more of this in later steps involving the Docker Compose `.yml` files, but as far as Webpack is concerned, we'll need to provide it a config file for the proxy: \n\n`frontend/src/setupProxy.js`:\n```js\nconst { createProxyMiddleware } = require('http-proxy-middleware');\n\nconst EXPRESS_HOST = process.env.EXPRESS_HOST || 'localhost';\n\nmodule.exports = function(app) {\n  app.use(\n    '/api',\n    createProxyMiddleware({\n      target: `http://${EXPRESS_HOST}:5000`\n    })\n  );\n};\n```\n\nSince I don't know of a way to embed an environment variable in the `package.json` file, this more advanced `setupProxy.js` file is necessary. Notice the environment variable `EXPRESS_HOST`. We will provide this variable to our Docker container, through our Docker Compose config. More on the above proxy config here: \u003chttps://create-react-app.dev/docs/proxying-api-requests-in-development/#configuring-the-proxy-manually\u003e\n\n`frontend/Dockerfile.prod`:\n```dockerfile\nFROM node:14 as builder\nWORKDIR /usr/src/frontend\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN npm run build\n\nFROM nginx\nCOPY --from=builder /usr/src/frontend/build /usr/share/nginx/html\nCOPY nginx.conf /etc/nginx/conf.d/\nEXPOSE 8080\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n\nThis is considered a multi-stage Docker build, due to the multiple `FROM` statements. We build our Webpack bundle, beginning from the `node:14` base image, and then switch to the `nginx` base image to serve that Webpack bundle. Notice the line `COPY nginx.conf /etc/nginx/conf.d/`, which refers to a `nginx.conf` file I keep in Git.\n\n`frontend/nginx.conf`:\n```\nserver {\n    listen 8080;\n\n    location /api {\n        proxy_pass http://backend:5000;\n    }\n\n    location / {\n        root /usr/share/nginx/html;\n        try_files $uri /index.html;\n    }\n}\n```\n\n**Note that my `nginx.conf` is a bit abnormal**, since my server hosting the site has another Nginx instance running outside of Docker, which I have setup with `location / { proxy_pass http://localhost:8080; }`. I have it setup this way so I can host multiple sites, and have Nginx handle routing traffic based on the `server_name`. You'll probably want your `nginx.conf` setup to include sections for Certbot, to manage SSL certificates, and listen on port 80 \u0026 443. Consult another tutorial on Certbot \u0026 Nginx for that.\n\nThe portion of this `nginx.conf` file that is applicable to you is the `proxy_pass` setup for `/api` requests, which sends it to the network host `backend` on port `5000`. This is Docker managing networking again. In this case, `backend`, is the name of our docker-compose service for Express, so Docker provides us the address for that specific container under the hostname `backend`.\n\nBefore we get to those Docker Compose files that link everything together, there's one more Dockerfile:\n\n`backend/Dockerfile`:\n```dockerfile\nFROM node:14\nWORKDIR /usr/src/backend\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nEXPOSE 5000\nCMD [\"node\", \"app.js\"]\n```\n\nFor the backend, I don't currently have a separate dev \u0026 prod Dockerfile, however I would recommend it, with the use of `nodemon` in place of `node` in the `CMD` statement in `Dockerfile.dev`, to enable hot reloading in development.\n\nNow onto the `docker-compose.yml` files. I have 3 of these under the filenames `docker-compose.yml`, `docker-compose.override.yml`, and `docker-compose.prod.yml`. You can choose different filenames, but there is a rational for these specific filenames. Both `docker-compose.yml` and `docker-compose.override.yml` are [filenames that Docker specifically looks for](https://docs.docker.com/compose/extends/). In both dev \u0026 prod, we use 2 of these 3 docker-compose files.\n\n* `docker-compose.yml` - The base config for dev \u0026 prod\n* `docker-compose.override.yml` - The dev config overrides\n* `docker-compose.prod.yml` - The prod config overrides\n\nAs shown in the Docker Compose docs linked above, multiple compose files can be specified with `-f` like so (also see `docker-compose --help`):  \n`docker-compose -f docker-compose.yml -f docker-compose.prod.yml [COMMAND] [ARGS...]`\n\nCompose files specified are read from left to right, which means `docker-compose.prod.yml` will be read last, giving it priority over our base `docker-compose.yml`.\n\nIf no files are specified with `-f`, Docker will do this:\n`docker-compose -f docker-compose.yml -f docker-compose.override.yml [COMMAND] [ARGS...]`\n\nWhy does this matter? In development, when you want to use the dev config, **you don't have to specify compose files for every `docker-compose` command you want to execute**. Running your entire application's stack in development becomes one short command: `docker-compose up`. That's it. Finally, here are those compose files:\n\n`docker-compose.yml`:\n```yml\nversion: \"3.8\"\n\nservices:\n  frontend:\n    build:\n      context: ./frontend\n    environment:\n      EXPRESS_HOST: backend\n\n  backend:\n    build:\n      context: ./backend\n      dockerfile: Dockerfile\n    ports:\n      - \"5000:5000\"\n    env_file: ./backend/.env\n    environment:\n      HOST: 0.0.0.0\n      MONGO_HOST: mongo\n\n  mongo:\n    image: mongo:latest\n    ports:\n      - \"127.0.0.1:27017:27017\"\n    volumes:\n      - mongo-data:/data/db\n\nvolumes:\n  mongo-data:\n```\n\n`docker-compose.override.yml`:\n```yml\nservices:\n  frontend:\n    build:\n      dockerfile: ./Dockerfile.dev\n    ports:\n      - \"3000:3000\"\n    environment:\n      NODE_ENV: development\n    volumes:\n      - ./frontend:/usr/src/frontend\n      - /usr/src/frontend/node_modules\n    # Due to stupid react-scripts bug still present in v3.4.3\n    # https://github.com/facebook/create-react-app/issues/8688\n    stdin_open: true\n\n  backend:\n    environment:\n      NODE_ENV: development\n    volumes:\n      - ./backend:/usr/src/backend\n      - /usr/src/backend/node_modules\n```\n\n`docker-compose.prod.yml`:\n```yml\nservices:\n  frontend:\n    build:\n      dockerfile: ./Dockerfile.prod\n    ports:\n      - \"127.0.0.1:8080:8080\"\n    environment:\n      NODE_ENV: production\n\n  backend:\n    environment:\n      NODE_ENV: production\n```\n\nThere's a lot we could go over in these compose files. I mentioned in the beginning that we want to enable hot-reloading in development, so that changes to code made on our host computer, are reflected in our Docker container, triggering a hot-reload from webpack-dev-server (or nodemon). The way we reflect file changes between host and container is through specifying `volumes`:\n\n```yml\nvolumes:\n  - ./frontend:/usr/src/frontend\n  - /usr/src/frontend/node_modules\n```\n\n`./frontend:/usr/src/frontend` maps our host's `./frontend` directory, to our container's `/usr/src/frontend` directory. Since our host may have its own `node_modules` directory inside `./frontend`, we don't want this to be shared with the container. The container needs to maintain its own installed dependencies in isolation. To prevent our container's `node_modules` from being overwritten, we create an anonymous volume of our container's `/usr/src/frontend/node_modules` directory. The ordering of the two volumes listed is important, so that our container's `node_modules` stored in a volume have highest priority (applied last). I would recommend doing other research on Docker volumes to better understand the different types of volumes that Docker supports. Just note that we can tell Docker to persist its own `node_modules` by creating an anonymous volume (we don't assign a name to it), that Docker keeps track of with a generated hash as the volume name. This volume persists between container instances.\n\nOn the subject of volumes, another volume is very important to persist data in our Mongo database. Without a volume, our Mongo data would be lost every time out container stops and starts again, and we definitely don't want to lose our DB data, at least in production. You'll notice this volume is mentioned in two places:\n\n```yml\n  mongo:\n    image: mongo:latest\n    ports:\n      - \"127.0.0.1:27017:27017\"\n    volumes:\n      - mongo-data:/data/db\n\nvolumes:\n  mongo-data:\n```\n\nWhy does `mongo-data` appear twice? In this situation, we're using a \"named volume\" (again, highly recommend reading more on these volume types). A named volume behaves quite similar to the anonymous volume I described earlier, except it's named! We could technically make this volume anonymous, but it's good to be able to identify the volume in case we need to manipulate it somehow, like making a backup of our database data. Named volumes must be defined in the top-level `volumes` key, that's why it appears in two places, unlike anonymous volumes.\n\nSee the Docker Compose docs on volumes: \u003chttps://docs.docker.com/compose/compose-file/#volumes\u003e\n\nYou may have noticed that ports are usually mapped like `\"\u003cport\u003e:\u003cport\u003e\"`, without specifying a host. With this shorthand, the host is implied to be `0.0.0.0`, listening on all interfaces. This makes it publicly accessible outside of the machine. If you don't need to directly access Mongo (via the Mongo shell) remotely, and can instead do so over SSH, I highly recommend that for security. Especially with the default Mongo config for Docker, there will be no credentials required to access Mongo. This means that an attacker who only knows the IP address of your server can remotely access your database! Yes, I did learn that the hard way, thankfully with non-consequential data. :sweat_smile: So do yourself a favor and specify the mapping `127.0.0.1:27017:27017` (`localhost` for the host, implicit `0.0.0.0` for the container).\n","slug":"dockerizing-a-mern-app-for-development-and-production"}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"dockerizing-a-mern-app-for-development-and-production"},"buildId":"7PXe33b0ovhWkt1a7aaJz","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
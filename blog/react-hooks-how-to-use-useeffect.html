<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>React Hooks: How to Use useEffect</title><meta name="next-head-count" content="3"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/_next/static/css/069ff64b07ed1af4.css" as="style"/><link rel="stylesheet" href="/_next/static/css/069ff64b07ed1af4.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-eae37baa130ab03a.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-9d34f203832e9748.js" defer=""></script><script src="/_next/static/chunks/pages/_app-0f31e0da3388de53.js" defer=""></script><script src="/_next/static/chunks/792-95b7cdfb484c5ddc.js" defer=""></script><script src="/_next/static/chunks/619-3b017027e2c3e013.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-5f9c197cd670af7e.js" defer=""></script><script src="/_next/static/OQmiqBYF7sZS2oj3gSzR8/_buildManifest.js" defer=""></script><script src="/_next/static/OQmiqBYF7sZS2oj3gSzR8/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">html{font-size:16px;min-height:100vh;}/*!sc*/
html,body{height:100%;margin:0;padding:0;}/*!sc*/
@media only screen and (max-device-width:480px){html{font-size:14px;}}/*!sc*/
body{background-color:#3e4d4f;color:white;font-family: -apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}/*!sc*/
*{box-sizing:border-box;}/*!sc*/
h1,h2,h3,h4,h5,h6{font-weight:400;}/*!sc*/
code,code[class*="language-"]{font-family: 'Inconsolata',Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace;}/*!sc*/
data-styled.g1[id="sc-global-bLrfTZ1"]{content:"sc-global-bLrfTZ1,"}/*!sc*/
.oXjRv{background-color:#272822;padding:0.2em 0.4em;font-size:0.8em;border-radius:0.3em;color:#ae81ff;-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g2[id="A__A_-sc-14fqd0c-0"]{content:"oXjRv,"}/*!sc*/
.imupSn{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:flex-start;-webkit-box-align:flex-start;-ms-flex-align:flex-start;align-items:flex-start;font-size:1.2em;-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g3[id="Navigation__Nav-sc-10fffhi-0"]{content:"imupSn,"}/*!sc*/
.bvlkze{margin:5px;}/*!sc*/
data-styled.g4[id="Navigation___StyledLink-sc-10fffhi-1"]{content:"bvlkze,"}/*!sc*/
.fCyYsH{margin:5px;}/*!sc*/
data-styled.g5[id="Navigation___StyledLink2-sc-10fffhi-2"]{content:"fCyYsH,"}/*!sc*/
.cLfdjf{margin:5px;}/*!sc*/
data-styled.g6[id="Navigation___StyledLink3-sc-10fffhi-3"]{content:"cLfdjf,"}/*!sc*/
.djnaNa{margin:5px;color:white;font-weight:500;line-height:1;}/*!sc*/
data-styled.g7[id="Navigation___StyledSpan-sc-10fffhi-4"]{content:"djnaNa,"}/*!sc*/
.fRlBcp{background-color:#272822;padding:0.2em 0.4em;font-size:0.8em;border-radius:0.3em;}/*!sc*/
data-styled.g8[id="Code-sc-1amjnp4-0"]{content:"fRlBcp,"}/*!sc*/
.cTrNrc{margin-left:auto !important;margin-right:auto !important;}/*!sc*/
data-styled.g9[id="TreeToJSX__Pre-sc-1taxolb-0"]{content:"cTrNrc,"}/*!sc*/
.gacNJW > p{margin:0;}/*!sc*/
data-styled.g11[id="TreeToJSX__Li-sc-1taxolb-2"]{content:"gacNJW,"}/*!sc*/
.gjkXwZ{font-size:1.2em;line-height:1.4em;-webkit-letter-spacing:0.01em;-moz-letter-spacing:0.01em;-ms-letter-spacing:0.01em;letter-spacing:0.01em;overflow-wrap:break-word;padding:1.1em;margin:0 auto;}/*!sc*/
.gjkXwZ > *:not(pre){max-width:850px;margin-left:auto;margin-right:auto;}/*!sc*/
.gjkXwZ > pre{width:90vw;max-width:1100px;}/*!sc*/
data-styled.g14[id="BlogContent__Container-sc-10yyr2o-0"]{content:"gjkXwZ,"}/*!sc*/
.czPvNY{text-align:center;margin:2em;margin-bottom:0.2em;}/*!sc*/
data-styled.g15[id="slug___StyledH-sc-8mhdoa-0"]{content:"czPvNY,"}/*!sc*/
.eAxGCo{font-size:0.9em;text-align:center;}/*!sc*/
data-styled.g16[id="slug___StyledP-sc-8mhdoa-1"]{content:"eAxGCo,"}/*!sc*/
</style><style data-href="https://fonts.googleapis.com/css2?family=Inconsolata&display=swap">@font-face{font-family:'Inconsolata';font-style:normal;font-weight:400;font-stretch:normal;font-display:swap;src:url(https://fonts.gstatic.com/s/inconsolata/v31/QldgNThLqRwH-OJ1UHjlKENVzkWGVkL3GZQmAwLYxYWI2qfdm7Lpp4U8aRk.woff) format('woff')}@font-face{font-family:'Inconsolata';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/inconsolata/v31/QldgNThLqRwH-OJ1UHjlKENVzkWGVkL3GZQmAwLYxYWI2qfdm7Lpp4U8WRL2kXWdycuJDETf.woff) format('woff');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Inconsolata';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/inconsolata/v31/QldgNThLqRwH-OJ1UHjlKENVzkWGVkL3GZQmAwLYxYWI2qfdm7Lpp4U8WRP2kXWdycuJDETf.woff) format('woff');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Inconsolata';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/inconsolata/v31/QldgNThLqRwH-OJ1UHjlKENVzkWGVkL3GZQmAwLYxYWI2qfdm7Lpp4U8WR32kXWdycuJDA.woff) format('woff');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><div><nav class="Navigation__Nav-sc-10fffhi-0 imupSn"><a href="/" target="_self" rel="noopener noreferrer" class="A__A_-sc-14fqd0c-0 oXjRv Navigation___StyledLink-sc-10fffhi-1 bvlkze">/</a><span class="Navigation___StyledSpan-sc-10fffhi-4 djnaNa">&gt;</span><a href="/blog" target="_self" rel="noopener noreferrer" class="A__A_-sc-14fqd0c-0 oXjRv Navigation___StyledLink2-sc-10fffhi-2 fCyYsH">blog</a><span class="Navigation___StyledSpan-sc-10fffhi-4 djnaNa">&gt;</span><a href="/blog/react-hooks-how-to-use-useeffect" target="_self" rel="noopener noreferrer" class="A__A_-sc-14fqd0c-0 oXjRv Navigation___StyledLink3-sc-10fffhi-3 cLfdjf">react-hooks-how-to-use-useeffect</a></nav><main><header><h1 class="slug___StyledH-sc-8mhdoa-0 czPvNY">React Hooks: How to Use useEffect</h1><p class="slug___StyledP-sc-8mhdoa-1 eAxGCo"><time dateTime="2021-03-04T18:04:42.446Z">March 4, 2021</time></p></header><article><div class="BlogContent__Container-sc-10yyr2o-0 gjkXwZ"><p>Of all the hooks built into React, <code class="Code-sc-1amjnp4-0 fRlBcp">useEffect</code> is arguably the most difficult to understand. When I was learning React Hooks, I had just begun to get comfortable with class-based components and the lifecycle methods, such as <code class="Code-sc-1amjnp4-0 fRlBcp">componentDidMount</code>. Part of the difficulty I had when learning <code class="Code-sc-1amjnp4-0 fRlBcp">useEffect</code> was due to the fundamental differences between <code class="Code-sc-1amjnp4-0 fRlBcp">useEffect</code> and the legacy React lifecycle methods. The best tutorials I&#x27;ve read on <code class="Code-sc-1amjnp4-0 fRlBcp">useEffect</code> advise you to &quot;unlearn what you have learned&quot; in regard to lifecycle methods.</p><p><a href="https://overreacted.io/a-complete-guide-to-useeffect" target="_blank" rel="noopener noreferrer" class="A__A_-sc-14fqd0c-0 oXjRv">Dan Abramov has an excellent blog post on useEffect</a>. It&#x27;s very thorough, and thus a long read. This post will summarize many of the points Dan covers, and I&#x27;ll cover some of the issues and solutions I&#x27;ve discovered while using <code class="Code-sc-1amjnp4-0 fRlBcp">useEffect</code>.</p><p>First, here is the function signature for <code class="Code-sc-1amjnp4-0 fRlBcp">useEffect</code> as a TypeScript definition:</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc language-ts" tabindex="0"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name">useEffect</span> <span class="token operator">=</span> <span class="token punctuation">(</span>effect<span class="token operator">:</span> EffectCallback<span class="token punctuation">,</span> deps<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">EffectCallback</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code class="Code-sc-1amjnp4-0 fRlBcp">EffectCallback</code> is our function to execute as the effect, which can optionally return a <a href="https://reactjs.org/docs/hooks-reference.html#cleaning-up-an-effect" target="_blank" rel="noopener noreferrer" class="A__A_-sc-14fqd0c-0 oXjRv">cleanup function</a> that will be executed when the component unmounts, or when the effect is redefined. The optional second argument to <code class="Code-sc-1amjnp4-0 fRlBcp">useEffect</code>, <code class="Code-sc-1amjnp4-0 fRlBcp">deps</code>, is a &quot;dependency array&quot;. If <code class="Code-sc-1amjnp4-0 fRlBcp">deps</code> is omitted, then the effect will be executed (and redefined) after every render. When <code class="Code-sc-1amjnp4-0 fRlBcp">deps</code> is included, the effect is only redefined and executed if any of the values provided to the array change from one execution to the next. Consequently, providing no values to the dependency array, <code class="Code-sc-1amjnp4-0 fRlBcp">[]</code>, will result in the effect only being executed after the initial render. In determining if a dependency has changed, as far as I know, a strict equality comparison is performed (<code class="Code-sc-1amjnp4-0 fRlBcp">===</code>). Note that arrays, objects, and functions are only equal by reference. In some situations this can be problematic. This blog post provides several solutions:<br/><a href="https://www.benmvp.com/blog/object-array-dependencies-react-useEffect-hook" target="_blank" rel="noopener noreferrer" class="A__A_-sc-14fqd0c-0 oXjRv">Object &amp; array dependencies in the React useEffect Hook</a></p><p>Why is it even necessary to have a dependency array? How could we be accessing stale values inside an effect?</p><p>Consider the following snippet of vanilla JS:</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc language-js" tabindex="0"><code class="language-js"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">pushFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  y<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> x <span class="token operator">=</span> y<span class="token punctuation">;</span>
  arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">pushFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">pushFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span></code></pre><p>We push two functions to an array, <code class="Code-sc-1amjnp4-0 fRlBcp">() =&gt; x</code>, and each time this function is created, it captures <code class="Code-sc-1amjnp4-0 fRlBcp">x</code> from its <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" target="_blank" rel="noopener noreferrer" class="A__A_-sc-14fqd0c-0 oXjRv">closure</a> within <code class="Code-sc-1amjnp4-0 fRlBcp">pushFunc</code>. <code class="Code-sc-1amjnp4-0 fRlBcp">x</code> from the first execution of <code class="Code-sc-1amjnp4-0 fRlBcp">pushFunc</code> is not the same <code class="Code-sc-1amjnp4-0 fRlBcp">x</code> in the second execution of <code class="Code-sc-1amjnp4-0 fRlBcp">pushFunc</code>. When dealing with React, the same rules apply, whether those values come from props or state, as they&#x27;re also just variables. This is because a React component is just a function, and plays by the same rules concerning function execution context.<br/>1 render = 1 function call.</p><p>If we were to provide a function to <code class="Code-sc-1amjnp4-0 fRlBcp">useEffect</code> with no dependency array; <code class="Code-sc-1amjnp4-0 fRlBcp">useEffect(() =&gt; {...})</code>, the effect function we provide would be redefined after every render, receiving fresh values from the current execution context. The effect would also re-execute after every render. The dependency array serves two purposes:</p><ol><li class="TreeToJSX__Li-sc-1taxolb-2 gacNJW"><p>Tell React when to execute our effect</p></li><li class="TreeToJSX__Li-sc-1taxolb-2 gacNJW"><p>Tell React when to redefine our effect</p></li></ol><h2 id="example-1-basic-usage-with">Example 1: Basic Usage with <code class="Code-sc-1amjnp4-0 fRlBcp">fetch</code></h2><p>The most common use case for <code class="Code-sc-1amjnp4-0 fRlBcp">useEffect</code> is fetching data from an API, and then updating the state of a component to render that data in the UI.</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc language-jsx" tabindex="0"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Todo</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> id <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>todo<span class="token punctuation">,</span> setTodo<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/api/todos/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">json</span> <span class="token operator">=></span> <span class="token function">setTodo</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>todo<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>todo<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>While we should avoid making too many comparisons to the class lifecycle methods, the above usage of <code class="Code-sc-1amjnp4-0 fRlBcp">useEffect</code> with an empty dependency array <code class="Code-sc-1amjnp4-0 fRlBcp">[]</code> is the rough equivalent of <code class="Code-sc-1amjnp4-0 fRlBcp">componentDidMount</code>. The above does work in its current form, but we&#x27;re lying to React about the dependency array. Running the above snippet through <code class="Code-sc-1amjnp4-0 fRlBcp">eslint</code> configured with the rule <code class="Code-sc-1amjnp4-0 fRlBcp">react-hooks/exhaustive-deps</code> gives us this warning:</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc language-none" tabindex="0"><code class="language-none">React Hook useEffect has a missing dependency: &#x27;id&#x27;.
Either include it or remove the dependency array</code></pre><p>We can fix this to become:</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc language-jsx" tabindex="0"><code class="language-jsx"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>By providing <code class="Code-sc-1amjnp4-0 fRlBcp">id</code> to the dependency array we are saying:<br/>&quot;Whenever <code class="Code-sc-1amjnp4-0 fRlBcp">id</code> changes, redefine and rerun this effect.&quot;</p><p><code class="Code-sc-1amjnp4-0 fRlBcp">id</code> may or may not change depending on how the parent component of our <code class="Code-sc-1amjnp4-0 fRlBcp">Todo</code> component gets a todo id, and provides that prop. If our <code class="Code-sc-1amjnp4-0 fRlBcp">Todo</code> component were to receive a different <code class="Code-sc-1amjnp4-0 fRlBcp">id</code> prop, then we probably would want to fetch the todo corresponding to that new id, calling our effect provided to <code class="Code-sc-1amjnp4-0 fRlBcp">useEffect</code> again.</p><p>Technically <code class="Code-sc-1amjnp4-0 fRlBcp">setTodo</code> should be included in the dependency array too. However, since it is a function we get from our <code class="Code-sc-1amjnp4-0 fRlBcp">useState</code> hook, its identity is guaranteed to be stable, so it will never change. Furthermore, <b>in newer versions of the <code class="Code-sc-1amjnp4-0 fRlBcp">react-hooks/exhaustive-deps</code> rule, the linter won&#x27;t tell us to include a <code class="Code-sc-1amjnp4-0 fRlBcp">useState</code> <code class="Code-sc-1amjnp4-0 fRlBcp">set_</code> function, nor the <code class="Code-sc-1amjnp4-0 fRlBcp">dispatch</code> function returned by <code class="Code-sc-1amjnp4-0 fRlBcp">useReducer</code>.</b> It&#x27;s safe to omit these specific functions from the dependency array. Just not other functions, as we will see in the next section.</p><h2 id="example-2-functions-as-dependencies">Example 2: Functions as Dependencies</h2><p>Next, let&#x27;s take a look at functions as effect dependencies:</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc language-jsx" tabindex="0"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Todo</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> id <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>todo<span class="token punctuation">,</span> setTodo<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">fetchTodo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/api/todos/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">fetchTodo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">json</span> <span class="token operator">=></span> <span class="token function">setTodo</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>todo<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>todo<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>In this example, our effect calls a function, <code class="Code-sc-1amjnp4-0 fRlBcp">fetchTodo</code>. This code contains a bug. 🐛 Because we omit <code class="Code-sc-1amjnp4-0 fRlBcp">fetchTodo</code> from our effect&#x27;s dependency array, our effect captures only the original definition of <code class="Code-sc-1amjnp4-0 fRlBcp">fetchTodo</code>, and in turn, that instance of <code class="Code-sc-1amjnp4-0 fRlBcp">fetchTodo</code> only captures the initial value of the <code class="Code-sc-1amjnp4-0 fRlBcp">id</code> prop. If <code class="Code-sc-1amjnp4-0 fRlBcp">id</code> changes, our effect will reference the original stale value. Like in the first example, <code class="Code-sc-1amjnp4-0 fRlBcp">id</code> is a dependency we need to inform our effect about. The difference is, we&#x27;ve now made that dependency indirect by accessing <code class="Code-sc-1amjnp4-0 fRlBcp">id</code> inside <code class="Code-sc-1amjnp4-0 fRlBcp">fetchTodo</code> rather than directly inside our effect callback.</p><p>There&#x27;s a problem with simply adding <code class="Code-sc-1amjnp4-0 fRlBcp">fetchTodo</code> to the dependency array to solve this. Because <code class="Code-sc-1amjnp4-0 fRlBcp">fetchTodo</code> will be redefined on each render / execution of our <code class="Code-sc-1amjnp4-0 fRlBcp">Todo</code> component, <code class="Code-sc-1amjnp4-0 fRlBcp">fetchTodo</code> will have a new &quot;value&quot; / &quot;function identity&quot; each time, resulting in the effect being triggered on every render. There are two solutions to this problem:</p><h3 id="solution-1">Solution #1</h3><p>Include <code class="Code-sc-1amjnp4-0 fRlBcp">fetchTodo</code> in the dependency array, and define <code class="Code-sc-1amjnp4-0 fRlBcp">fetchTodo</code> with <a href="https://reactjs.org/docs/hooks-reference.html#usecallback" target="_blank" rel="noopener noreferrer" class="A__A_-sc-14fqd0c-0 oXjRv">useCallback</a>. Like <code class="Code-sc-1amjnp4-0 fRlBcp">useEffect</code>, <code class="Code-sc-1amjnp4-0 fRlBcp">useCallback</code> also accepts a dependency array. Because <code class="Code-sc-1amjnp4-0 fRlBcp">fetchTodo</code> references <code class="Code-sc-1amjnp4-0 fRlBcp">id</code> in its function body, we need to include <code class="Code-sc-1amjnp4-0 fRlBcp">id</code> in its dependency array:</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc language-jsx" tabindex="0"><code class="language-jsx"><span class="token keyword">const</span> fetchTodo <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/api/todos/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Whenever `id` changes, `fetchTodo` will be redefined</span>

<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token function">fetchTodo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">json</span> <span class="token operator">=></span> <span class="token function">setTodo</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>fetchTodo<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Add `fetchTodo` to the effect's dependency array</span></code></pre><h3 id="solution-2">Solution #2</h3><p>The other solution is to extract <code class="Code-sc-1amjnp4-0 fRlBcp">fetchTodo</code> from the component entirely. Being outside the closure of the <code class="Code-sc-1amjnp4-0 fRlBcp">Todo</code> component, it won&#x27;t have access to the <code class="Code-sc-1amjnp4-0 fRlBcp">id</code> prop, but we can supply that as an argument to the function. Extracting <code class="Code-sc-1amjnp4-0 fRlBcp">fetchTodo</code> will allow its function identity to be stable across renders of <code class="Code-sc-1amjnp4-0 fRlBcp">Todo</code>:</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc language-jsx" tabindex="0"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Todo</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> id <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>todo<span class="token punctuation">,</span> setTodo<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">fetchTodo</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token comment">// Pass `id` as an argument</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">json</span> <span class="token operator">=></span> <span class="token function">setTodo</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// `fetchTodo` now has a stable function identity</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>todo<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>todo<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">fetchTodo</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Make `id` an argument</span>
  <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/api/todos/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><h2 id="example-3-access-updated">Example 3: Access Updated <code class="Code-sc-1amjnp4-0 fRlBcp">props</code> Without Rerunning an Effect</h2><p>Let&#x27;s look at another example. This one is a fairly unique case, as we need to access updated values in our effect, but re-executing the effect actually breaks the functionality we&#x27;re going for:</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc language-jsx" tabindex="0"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> incrementBy <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> setNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> handle <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">setNum</span><span class="token punctuation">(</span>num <span class="token operator">+</span> incrementBy<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> incrementBy<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>num<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><code class="Code-sc-1amjnp4-0 fRlBcp">setNum</code> won&#x27;t change, but <code class="Code-sc-1amjnp4-0 fRlBcp">num</code> and <code class="Code-sc-1amjnp4-0 fRlBcp">incrementBy</code> are both problematic. With <code class="Code-sc-1amjnp4-0 fRlBcp">num</code> in the dependency array, and our effect updating <code class="Code-sc-1amjnp4-0 fRlBcp">num</code> via <code class="Code-sc-1amjnp4-0 fRlBcp">setNum</code>, this will cause our effect to be triggered every time <code class="Code-sc-1amjnp4-0 fRlBcp">setNum(num + incrementBy)</code> is run. For setting state relying on previous state values, we can use the callback form of <code class="Code-sc-1amjnp4-0 fRlBcp">setState</code>, and remove <code class="Code-sc-1amjnp4-0 fRlBcp">num</code> as a dependency.</p><p>If <code class="Code-sc-1amjnp4-0 fRlBcp">num</code> is omitted from the dependency array, the linter will actually suggest this solution to us:</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc language-none" tabindex="0"><code class="language-none">React Hook useEffect has a missing dependency: &#x27;num&#x27;.
Either include it or remove the dependency array.
You can also do a functional update &#x27;setNum(n =&gt; ...)&#x27;
if you only need &#x27;num&#x27; in the &#x27;setNum&#x27; call</code></pre><p>To use the functional update form of <code class="Code-sc-1amjnp4-0 fRlBcp">setState</code>, we can change this to:</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc language-jsx" tabindex="0"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> incrementBy <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> setNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> handle <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">setNum</span><span class="token punctuation">(</span><span class="token parameter">prevNum</span> <span class="token operator">=></span> prevNum <span class="token operator">+</span> incrementBy<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// `num` is no longer used here</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>incrementBy<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// `num` removed from dependency array</span>

  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>num<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Now we&#x27;re left to deal with <code class="Code-sc-1amjnp4-0 fRlBcp">incrementBy</code>. If this prop is updated, say from <code class="Code-sc-1amjnp4-0 fRlBcp">10</code> to <code class="Code-sc-1amjnp4-0 fRlBcp">20</code>, we do want that updated value to be referenced in our effect, rather than referencing a stale value. However, when our effect is redefined, we lose the timing of our interval, and a new interval is created. We have it setup to call <code class="Code-sc-1amjnp4-0 fRlBcp">setNum(prevNum =&gt; prevNum + incrementBy)</code> every 3 seconds.</p><p>What happens if just 1.5 seconds have passed for the interval, and the value of <code class="Code-sc-1amjnp4-0 fRlBcp">incrementBy</code> changes?</p><ol><li class="TreeToJSX__Li-sc-1taxolb-2 gacNJW"><p>Our effect cleanup function we provided to React will be executed, <code class="Code-sc-1amjnp4-0 fRlBcp">() =&gt; clearInterval(handle)</code>, clearing our current 3 second interval.</p></li><li class="TreeToJSX__Li-sc-1taxolb-2 gacNJW"><p>Our effect will be redefined, creating a new 3 second interval, along with a new cleanup function.</p></li><li class="TreeToJSX__Li-sc-1taxolb-2 gacNJW"><p>From there, 3 more seconds must pass before <code class="Code-sc-1amjnp4-0 fRlBcp">setNum(...)</code> is called, for a total of 4.5 seconds since the last interval call (wrong behavior).</p></li></ol><p>This example with <code class="Code-sc-1amjnp4-0 fRlBcp">setInterval</code> provides us with a unique challenge. We want the updated values present in our effect, but we don&#x27;t want the timing of our interval to be messed up, as a result of redefining our effect. <code class="Code-sc-1amjnp4-0 fRlBcp">useReducer</code> can help us achieve this, by accessing updated props in our reducer function, rather than in <code class="Code-sc-1amjnp4-0 fRlBcp">useEffect</code>:</p><pre class="TreeToJSX__Pre-sc-1taxolb-0 cTrNrc language-jsx" tabindex="0"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> incrementBy <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> incrementNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>
    <span class="token parameter">prevNum</span> <span class="token operator">=></span> prevNum <span class="token operator">+</span> incrementBy<span class="token punctuation">,</span> <span class="token comment">// Our "setter" (reducer function)</span>
    <span class="token number">0</span> <span class="token comment">// Initial state</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> handle <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">incrementNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>num<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>We use <code class="Code-sc-1amjnp4-0 fRlBcp">useReducer</code> in a similar fashion to <code class="Code-sc-1amjnp4-0 fRlBcp">useState</code>, but with the ability to specify what our &quot;setter&quot; function does, and for it to access updated props. <code class="Code-sc-1amjnp4-0 fRlBcp">useReducer</code> is flexible in how you use it for your state. It can be used for simple, single value state, or more complex state objects. By convention, you&#x27;d normally see <code class="Code-sc-1amjnp4-0 fRlBcp">useReducer</code> used like this: <code class="Code-sc-1amjnp4-0 fRlBcp">const [state, dispatch] = useReducer(...)</code>. We instead choose to name these <code class="Code-sc-1amjnp4-0 fRlBcp">num</code> &amp; <code class="Code-sc-1amjnp4-0 fRlBcp">incrementNum</code>. <code class="Code-sc-1amjnp4-0 fRlBcp">incrementNum</code> is our <code class="Code-sc-1amjnp4-0 fRlBcp">dispatch</code> function that <code class="Code-sc-1amjnp4-0 fRlBcp">useReducer</code> returns to us, and it is guaranteed to have a stable function identity, preventing it from triggering <code class="Code-sc-1amjnp4-0 fRlBcp">useEffect</code> to rerun. Since <code class="Code-sc-1amjnp4-0 fRlBcp">incrementNum</code> is the <code class="Code-sc-1amjnp4-0 fRlBcp">dispatch</code> function returned to us by <code class="Code-sc-1amjnp4-0 fRlBcp">useReducer</code>, it can be omitted from the dependency array and the exhaustive deps linter won&#x27;t complain.</p><h2 id="conclusion">Conclusion</h2><p>Hopefully this post helped in understanding <code class="Code-sc-1amjnp4-0 fRlBcp">useEffect</code>. As you can tell, the design of this hook by the React team is something that&#x27;s opinionated and strict in how it is intended to be used, though that&#x27;s not a bad thing. Being honest about an effect&#x27;s dependencies is important in avoiding subtle bugs. We looked at some tricks that can be used to limit the number of dependencies in our effects. These recommended workarounds to reduce dependencies are something I wish was documented a little better in the official React docs. One of the more helpful parts of the docs is the <a href="https://reactjs.org/docs/hooks-faq.html#performance-optimizations" target="_blank" rel="noopener noreferrer" class="A__A_-sc-14fqd0c-0 oXjRv">Hooks FAQ #Performance Optimizations</a> section, which to me seems like more of a general usage guide. Knowing these recommended strategies for working with <code class="Code-sc-1amjnp4-0 fRlBcp">useEffect</code> is crucial, as I&#x27;ve found that it&#x27;s very easy to &quot;break the rules&quot; of <code class="Code-sc-1amjnp4-0 fRlBcp">useEffect</code> when building real world applications.</p></div></article></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"React Hooks: How to Use useEffect","date":"2021-03-04T18:04:42.446Z","content":"\nOf all the hooks built into React, `useEffect` is arguably the most difficult to understand. When I was learning React Hooks, I had just begun to get comfortable with class-based components and the lifecycle methods, such as `componentDidMount`. Part of the difficulty I had when learning `useEffect` was due to the fundamental differences between `useEffect` and the legacy React lifecycle methods. The best tutorials I've read on `useEffect` advise you to \"unlearn what you have learned\" in regard to lifecycle methods.\n\n[Dan Abramov has an excellent blog post on useEffect](https://overreacted.io/a-complete-guide-to-useeffect). It's very thorough, and thus a long read. This post will summarize many of the points Dan covers, and I'll cover some of the issues and solutions I've discovered while using `useEffect`.\n\nFirst, here is the function signature for `useEffect` as a TypeScript definition:\n\n```ts\ntype useEffect = (effect: EffectCallback, deps?: Array\u003cany\u003e) =\u003e void;\ntype EffectCallback = () =\u003e (void | (() =\u003e void));\n```\n\n`EffectCallback` is our function to execute as the effect, which can optionally return a [cleanup function](https://reactjs.org/docs/hooks-reference.html#cleaning-up-an-effect) that will be executed when the component unmounts, or when the effect is redefined. The optional second argument to `useEffect`, `deps`, is a \"dependency array\". If `deps` is omitted, then the effect will be executed (and redefined) after every render. When `deps` is included, the effect is only redefined and executed if any of the values provided to the array change from one execution to the next. Consequently, providing no values to the dependency array, `[]`, will result in the effect only being executed after the initial render. In determining if a dependency has changed, as far as I know, a strict equality comparison is performed (`===`). Note that arrays, objects, and functions are only equal by reference. In some situations this can be problematic. This blog post provides several solutions:  \n[Object \u0026 array dependencies in the React useEffect Hook](https://www.benmvp.com/blog/object-array-dependencies-react-useEffect-hook)\n\nWhy is it even necessary to have a dependency array? How could we be accessing stale values inside an effect?\n\nConsider the following snippet of vanilla JS:\n```js\nlet arr = [];\nlet y = 0;\n\nfunction pushFunc() {\n  y++;\n  let x = y;\n  arr.push(() =\u003e x);\n}\n\npushFunc();\npushFunc();\n\nconsole.log(arr[0]()); // 1\nconsole.log(arr[1]()); // 2\n```\nWe push two functions to an array, `() =\u003e x`, and each time this function is created, it captures `x` from its [closure](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures) within `pushFunc`. `x` from the first execution of `pushFunc` is not the same `x` in the second execution of `pushFunc`. When dealing with React, the same rules apply, whether those values come from props or state, as they're also just variables. This is because a React component is just a function, and plays by the same rules concerning function execution context.  \n1 render = 1 function call.\n\nIf we were to provide a function to `useEffect` with no dependency array; `useEffect(() =\u003e {...})`, the effect function we provide would be redefined after every render, receiving fresh values from the current execution context. The effect would also re-execute after every render. The dependency array serves two purposes:\n1. Tell React when to execute our effect\n2. Tell React when to redefine our effect\n\n## Example 1: Basic Usage with `fetch`\nThe most common use case for `useEffect` is fetching data from an API, and then updating the state of a component to render that data in the UI.\n\n```jsx\nfunction Todo({ id }) {\n  const [todo, setTodo] = useState();\n\n  useEffect(() =\u003e {\n    fetch(`/api/todos/${id}`)\n      .then(res =\u003e res.json())\n      .then(json =\u003e setTodo(json));\n  }, []);\n\n  if (!todo) return null;\n  return \u003cdiv\u003e{todo.title}\u003c/div\u003e;\n}\n```\n\nWhile we should avoid making too many comparisons to the class lifecycle methods, the above usage of `useEffect` with an empty dependency array `[]` is the rough equivalent of `componentDidMount`. The above does work in its current form, but we're lying to React about the dependency array. Running the above snippet through `eslint` configured with the rule `react-hooks/exhaustive-deps` gives us this warning:\n```\nReact Hook useEffect has a missing dependency: 'id'.\nEither include it or remove the dependency array\n```\nWe can fix this to become:\n\n```jsx\nuseEffect(() =\u003e {\n  ...\n}, [id]);\n```\n\nBy providing `id` to the dependency array we are saying:  \n\"Whenever `id` changes, redefine and rerun this effect.\"\n\n`id` may or may not change depending on how the parent component of our `Todo` component gets a todo id, and provides that prop. If our `Todo` component were to receive a different `id` prop, then we probably would want to fetch the todo corresponding to that new id, calling our effect provided to `useEffect` again.\n\nTechnically `setTodo` should be included in the dependency array too. However, since it is a function we get from our `useState` hook, its identity is guaranteed to be stable, so it will never change. Furthermore, **in newer versions of the `react-hooks/exhaustive-deps` rule, the linter won't tell us to include a `useState` `set_` function, nor the `dispatch` function returned by `useReducer`.** It's safe to omit these specific functions from the dependency array. Just not other functions, as we will see in the next section.\n\n## Example 2: Functions as Dependencies\nNext, let's take a look at functions as effect dependencies:\n\n```jsx\nfunction Todo({ id }) {\n  const [todo, setTodo] = useState();\n\n  function fetchTodo() {\n    return fetch(`/api/todos/${id}`);\n  }\n\n  useEffect(() =\u003e {\n    fetchTodo()\n      .then(res =\u003e res.json())\n      .then(json =\u003e setTodo(json));\n  }, []);\n\n  if (!todo) return null;\n  return \u003cdiv\u003e{todo.title}\u003c/div\u003e;\n}\n```\n\nIn this example, our effect calls a function, `fetchTodo`. This code contains a bug. :bug: Because we omit `fetchTodo` from our effect's dependency array, our effect captures only the original definition of `fetchTodo`, and in turn, that instance of `fetchTodo` only captures the initial value of the `id` prop. If `id` changes, our effect will reference the original stale value. Like in the first example, `id` is a dependency we need to inform our effect about. The difference is, we've now made that dependency indirect by accessing `id` inside `fetchTodo` rather than directly inside our effect callback.\n\nThere's a problem with simply adding `fetchTodo` to the dependency array to solve this. Because `fetchTodo` will be redefined on each render / execution of our `Todo` component, `fetchTodo` will have a new \"value\" / \"function identity\" each time, resulting in the effect being triggered on every render. There are two solutions to this problem:\n\n### Solution #1\nInclude `fetchTodo` in the dependency array, and define `fetchTodo` with [useCallback](https://reactjs.org/docs/hooks-reference.html#usecallback). Like `useEffect`, `useCallback` also accepts a dependency array. Because `fetchTodo` references `id` in its function body, we need to include `id` in its dependency array:\n\n```jsx\nconst fetchTodo = useCallback(() =\u003e {\n  return fetch(`/api/todos/${id}`);\n}, [id]); // Whenever `id` changes, `fetchTodo` will be redefined\n\nuseEffect(() =\u003e {\n  fetchTodo()\n    .then(res =\u003e res.json())\n    .then(json =\u003e setTodo(json));\n}, [fetchTodo]); // Add `fetchTodo` to the effect's dependency array\n```\n\n### Solution #2\nThe other solution is to extract `fetchTodo` from the component entirely. Being outside the closure of the `Todo` component, it won't have access to the `id` prop, but we can supply that as an argument to the function. Extracting `fetchTodo` will allow its function identity to be stable across renders of `Todo`:\n```jsx\nfunction Todo({ id }) {\n  const [todo, setTodo] = useState();\n\n  useEffect(() =\u003e {\n    fetchTodo(id) // Pass `id` as an argument\n      .then(res =\u003e res.json())\n      .then(json =\u003e setTodo(json));\n  }, [id]); // `fetchTodo` now has a stable function identity\n\n  if (!todo) return null;\n  return \u003cdiv\u003e{todo.title}\u003c/div\u003e;\n}\n\nfunction fetchTodo(id) { // Make `id` an argument\n  return fetch(`/api/todos/${id}`);\n}\n```\n\n## Example 3: Access Updated `props` Without Rerunning an Effect\nLet's look at another example. This one is a fairly unique case, as we need to access updated values in our effect, but re-executing the effect actually breaks the functionality we're going for:\n\n```jsx\nfunction Counter({ incrementBy }) {\n  const [num, setNum] = useState(0);\n\n  useEffect(() =\u003e {\n    const handle = setInterval(() =\u003e {\n      setNum(num + incrementBy);\n    }, 3000);\n\n    return () =\u003e clearInterval(handle);\n  }, [num, incrementBy]);\n\n  return \u003cdiv\u003e{num}\u003c/div\u003e;\n}\n```\n\n`setNum` won't change, but `num` and `incrementBy` are both problematic. With `num` in the dependency array, and our effect updating `num` via `setNum`, this will cause our effect to be triggered every time `setNum(num + incrementBy)` is run. For setting state relying on previous state values, we can use the callback form of `setState`, and remove `num` as a dependency.\n\nIf `num` is omitted from the dependency array, the linter will actually suggest this solution to us:\n\n```\nReact Hook useEffect has a missing dependency: 'num'.\nEither include it or remove the dependency array.\nYou can also do a functional update 'setNum(n =\u003e ...)'\nif you only need 'num' in the 'setNum' call\n```\n\nTo use the functional update form of `setState`, we can change this to:\n\n```jsx\nfunction Counter({ incrementBy }) {\n  const [num, setNum] = useState(0);\n\n  useEffect(() =\u003e {\n    const handle = setInterval(() =\u003e {\n      setNum(prevNum =\u003e prevNum + incrementBy); // `num` is no longer used here\n    }, 3000);\n\n    return () =\u003e clearInterval(handle);\n  }, [incrementBy]); // `num` removed from dependency array\n\n  return \u003cdiv\u003e{num}\u003c/div\u003e;\n}\n```\n\nNow we're left to deal with `incrementBy`. If this prop is updated, say from `10` to `20`, we do want that updated value to be referenced in our effect, rather than referencing a stale value. However, when our effect is redefined, we lose the timing of our interval, and a new interval is created. We have it setup to call `setNum(prevNum =\u003e prevNum + incrementBy)` every 3 seconds.\n\nWhat happens if just 1.5 seconds have passed for the interval, and the value of `incrementBy` changes?\n1. Our effect cleanup function we provided to React will be executed, `() =\u003e clearInterval(handle)`, clearing our current 3 second interval.\n2. Our effect will be redefined, creating a new 3 second interval, along with a new cleanup function.\n3. From there, 3 more seconds must pass before `setNum(...)` is called, for a total of 4.5 seconds since the last interval call (wrong behavior).\n\nThis example with `setInterval` provides us with a unique challenge. We want the updated values present in our effect, but we don't want the timing of our interval to be messed up, as a result of redefining our effect. `useReducer` can help us achieve this, by accessing updated props in our reducer function, rather than in `useEffect`:\n```jsx\nfunction Counter({ incrementBy }) {\n  const [num, incrementNum] = useReducer(\n    prevNum =\u003e prevNum + incrementBy, // Our \"setter\" (reducer function)\n    0 // Initial state\n  );\n\n  useEffect(() =\u003e {\n    const handle = setInterval(() =\u003e {\n      incrementNum();\n    }, 3000);\n\n    return () =\u003e clearInterval(handle);\n  }, []);\n\n  return \u003cdiv\u003e{num}\u003c/div\u003e;\n}\n```\nWe use `useReducer` in a similar fashion to `useState`, but with the ability to specify what our \"setter\" function does, and for it to access updated props. `useReducer` is flexible in how you use it for your state. It can be used for simple, single value state, or more complex state objects. By convention, you'd normally see `useReducer` used like this: `const [state, dispatch] = useReducer(...)`. We instead choose to name these `num` \u0026 `incrementNum`. `incrementNum` is our `dispatch` function that `useReducer` returns to us, and it is guaranteed to have a stable function identity, preventing it from triggering `useEffect` to rerun. Since `incrementNum` is the `dispatch` function returned to us by `useReducer`, it can be omitted from the dependency array and the exhaustive deps linter won't complain.\n\n\n## Conclusion\nHopefully this post helped in understanding `useEffect`. As you can tell, the design of this hook by the React team is something that's opinionated and strict in how it is intended to be used, though that's not a bad thing. Being honest about an effect's dependencies is important in avoiding subtle bugs. We looked at some tricks that can be used to limit the number of dependencies in our effects. These recommended workarounds to reduce dependencies are something I wish was documented a little better in the official React docs. One of the more helpful parts of the docs is the [Hooks FAQ #Performance Optimizations](https://reactjs.org/docs/hooks-faq.html#performance-optimizations) section, which to me seems like more of a general usage guide. Knowing these recommended strategies for working with `useEffect` is crucial, as I've found that it's very easy to \"break the rules\" of `useEffect` when building real world applications.\n","slug":"react-hooks-how-to-use-useeffect"}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"react-hooks-how-to-use-useeffect"},"buildId":"OQmiqBYF7sZS2oj3gSzR8","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>